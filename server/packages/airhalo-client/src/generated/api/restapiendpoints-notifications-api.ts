/* tslint:disable */
/* eslint-disable */
/**
 *  Airalo Developer Platform 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { V2NotificationsOptInGet200Response } from '../models';
// @ts-ignore
import type { V2NotificationsOptInPost200Response } from '../models';
// @ts-ignore
import type { V2NotificationsOptInPostRequest } from '../models';
// @ts-ignore
import type { V2NotificationsOptOutPostRequest } from '../models';
// @ts-ignore
import type { V2SimulatorWebhookPost200Response } from '../models';
// @ts-ignore
import type { V2SimulatorWebhookPostRequest } from '../models';
/**
 * RESTAPIEndpointsNotificationsApi - axios parameter creator
 * @export
 */
export const RESTAPIEndpointsNotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A webhook is a method in the context of Airalo\'s API, which serves as a means to seamlessly push real-time data updates to our partner\'s designated endpoint URL. This functionality ensures timely and efficient data synchronization between our systems and those of our valued partners.  **NOTE: Whenever an optin is performed, the webhook_url parameter is checked by the system via HEAD request, to which it must respond with 200 OK to be considered successful**  There are three types:   \\- _**Credit Limit Notification**_   \\- _**Low Data Notification**_ \\- _**Async Order**_  ### Custom Header for Payload Signing  To enhance the security and integrity of transmitted data, our webhook implementation includes a custom header for payload signing which is a HMAC value with sha512 algorithm. Partners are _**strongly encouraged**_ to include this header in their requests to validate the authenticity and integrity of the payload.  Header name: `airalo-signature`  **Examples on how to verify the integrity of the received webhook event:**  ``` php function calculateHMAC($data, $key) {     return hash_hmac(\'sha512\', $data, $key); } // Your API secret define(\"API_SECRET\", \"<YOUR_API_SECRET>\"); // This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload. $payload = []; // Assign the actual payload here $airaloSignature = \"<AIRALO_SIGNATURE>\"; // Assign the actual header here, located in key `airalo-signature` // Check if the payload is an object, if so, convert it to a JSON string if (is_array($payload) || is_object($payload)) {     $payload = json_encode($payload); } // Calculate the expected signature using HMAC with SHA512 $expectedSignature = calculateHMAC($payload, API_SECRET); if ($expectedSignature === $airaloSignature) {     // Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.     // You can safely proceed with your flow.     echo \'Yay!\'; } else {     // We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.     echo \'Hmm.... it is suspicious\'; }   ```  ``` javascript const crypto = require(\'crypto\'); const API_SECRET = \"<YOUR_API_SECRET>\"; // This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload. let payload = \'{}\'; // Assign the actual payload here const airaloSignature = \"<AIRALO_SIGNATURE>\"; // Assign the actual header here, located in key `airalo-signature` if (typeof payload === \'object\') {     payload = JSON.stringify(payload); } const expectedSignature = crypto.createHmac(\'sha512\', API_SECRET).update(payload).digest(\'hex\'); if (expectedSignature === airaloSignature) {     // Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.     // You can safely proceed with your flow.     console.log(\'Yay!\'); } else {     // We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.     console.log(\'Hmm.... it is suspicious\'); }   ```  ``` python import hashlib import hmac import json API_SECRET = \"<YOUR_API_SECRET>\" # This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload. # Assign the actual payload here payload = {     \"foo\": \"bar\",     \"baz:\": \"mqu\", }  # Replace with the actual payload # Assign the actual header here, located in key `airalo-signature` airalo_signature = \"<AIRALO_SIGNATURE>\" if isinstance(payload, dict):     payload = json.dumps(payload, separators=(\',\', \':\')) expected_signature = hmac.new(bytes(API_SECRET, \'utf-8\'), msg=bytes(payload, \'utf-8\'), digestmod=hashlib.sha512).hexdigest() if hmac.compare_digest(expected_signature, airalo_signature):     # Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.     # You can safely proceed with your flow.     print(\'Yay!\') else:     # We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.     print(\'Hmm.... it is suspicious\')   ```  ``` java import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.util.Base64; public class AiraloWebhookVerification {     private static final String API_SECRET = \"<YOUR_API_SECRET>\";     public static void main(String[] args) {         // This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload.         // Assign the actual payload here         String payload = \"{}\";  // Replace with the actual payload         // Assign the actual header here, located in key `airalo-signature`         String airaloSignature = \"<AIRALO_SIGNATURE>\";         if (payload instanceof String) {             try {                 MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");                 byte[] hash = digest.digest(payload.getBytes(StandardCharsets.UTF_8));                 payload = bytesToHex(hash);             } catch (NoSuchAlgorithmException e) {                 e.printStackTrace();             }         }         String expectedSignature = generateHmacSHA512(API_SECRET, payload);         if (expectedSignature.equals(airaloSignature)) {             // Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.             // You can safely proceed with your flow.             System.out.println(\"Yay!\");         } else {             // We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.             System.out.println(\"Hmm.... it is suspicious\");         }     }     private static String generateHmacSHA512(String key, String data) {         try {             Mac sha512_HMAC = Mac.getInstance(\"HmacSHA512\");             SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), \"HmacSHA512\");             sha512_HMAC.init(secret_key);             byte[] bytes = sha512_HMAC.doFinal(data.getBytes(StandardCharsets.UTF_8));             return bytesToHex(bytes);         } catch (Exception e) {             e.printStackTrace();             return null;         }     }     private static String bytesToHex(byte[] bytes) {         StringBuilder result = new StringBuilder();         for (byte b : bytes) {             result.append(String.format(\"x\", b));         }         return result.toString();     } }   ```
         * @summary Webhook definition
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootPost: async (contentType: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('rootPost', 'contentType', contentType)
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to retrieve the details of low data notification from the Airalo Partners API. The access token, obtained from the \"Request Access Token\" endpoint, should be included in the request.  For more informations, best practices visit our FAQ page: [https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ](https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ)
         * @summary Get low data notification
         * @param {string} accept 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2NotificationsOptInGet: async (accept: string, authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('v2NotificationsOptInGet', 'accept', accept)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('v2NotificationsOptInGet', 'authorization', authorization)
            const localVarPath = `/v2/notifications/opt-in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receive notifications regarding your credit limit as it reaches specific thresholds. You have   the flexibility to opt-in for various levels based on your requirements. For instance, you can   choose to receive notifications at 90% of your credit limit or select multiple thresholds such   as 50%, 70%, and 90%. These notifications can be delivered either to your webhook or your   company email address.  **Parameters**  - \"type\": \"webhook_credit_limit\", - use this value to receive notification via webhook - \"email_credit_limit\" use this value to receive notification via email - \"webhook_url\": \"[https://example.com\"](https://example.com\") - in case of notification to be       delivered via your webhook implementation, provide your webhook       implementation url - “email” – email address is case of notification via company email address - “language” – “en” – in case of email based notification
         * @summary Credit limit notification
         * @param {string} accept 
         * @param {string} authorization 
         * @param {V2NotificationsOptInPostRequest} [v2NotificationsOptInPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2NotificationsOptInPost: async (accept: string, authorization: string, v2NotificationsOptInPostRequest?: V2NotificationsOptInPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('v2NotificationsOptInPost', 'accept', accept)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('v2NotificationsOptInPost', 'authorization', authorization)
            const localVarPath = `/v2/notifications/opt-in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2NotificationsOptInPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This feature allows you to opt out of notifications regarding low data usage depending upon the type passed in the request payload  For more informations, best practices visit our FAQ page: [https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ](https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ)
         * @summary Low data notification - opt out
         * @param {string} accept 
         * @param {string} authorization 
         * @param {V2NotificationsOptOutPostRequest} [v2NotificationsOptOutPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2NotificationsOptOutPost: async (accept: string, authorization: string, v2NotificationsOptOutPostRequest?: V2NotificationsOptOutPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('v2NotificationsOptOutPost', 'accept', accept)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('v2NotificationsOptOutPost', 'authorization', authorization)
            const localVarPath = `/v2/notifications/opt-out`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2NotificationsOptOutPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * With this endpoint parthers can trigger a Low Data Notification webhook event with mock data to their opted-in wehbook url. This is useful during testing/integration phase where developers can test their server when receiving such events.  Parameters  - \"event\" - string **required**      - \"type\" - string **required**      - \"iccid\" - string **optional**       For more informations, best practices visit our FAQ page: [https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ](https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ)
         * @summary Webhook simulator
         * @param {string} authorization 
         * @param {V2SimulatorWebhookPostRequest} [v2SimulatorWebhookPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SimulatorWebhookPost: async (authorization: string, v2SimulatorWebhookPostRequest?: V2SimulatorWebhookPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('v2SimulatorWebhookPost', 'authorization', authorization)
            const localVarPath = `/v2/simulator/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v2SimulatorWebhookPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RESTAPIEndpointsNotificationsApi - functional programming interface
 * @export
 */
export const RESTAPIEndpointsNotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RESTAPIEndpointsNotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * A webhook is a method in the context of Airalo\'s API, which serves as a means to seamlessly push real-time data updates to our partner\'s designated endpoint URL. This functionality ensures timely and efficient data synchronization between our systems and those of our valued partners.  **NOTE: Whenever an optin is performed, the webhook_url parameter is checked by the system via HEAD request, to which it must respond with 200 OK to be considered successful**  There are three types:   \\- _**Credit Limit Notification**_   \\- _**Low Data Notification**_ \\- _**Async Order**_  ### Custom Header for Payload Signing  To enhance the security and integrity of transmitted data, our webhook implementation includes a custom header for payload signing which is a HMAC value with sha512 algorithm. Partners are _**strongly encouraged**_ to include this header in their requests to validate the authenticity and integrity of the payload.  Header name: `airalo-signature`  **Examples on how to verify the integrity of the received webhook event:**  ``` php function calculateHMAC($data, $key) {     return hash_hmac(\'sha512\', $data, $key); } // Your API secret define(\"API_SECRET\", \"<YOUR_API_SECRET>\"); // This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload. $payload = []; // Assign the actual payload here $airaloSignature = \"<AIRALO_SIGNATURE>\"; // Assign the actual header here, located in key `airalo-signature` // Check if the payload is an object, if so, convert it to a JSON string if (is_array($payload) || is_object($payload)) {     $payload = json_encode($payload); } // Calculate the expected signature using HMAC with SHA512 $expectedSignature = calculateHMAC($payload, API_SECRET); if ($expectedSignature === $airaloSignature) {     // Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.     // You can safely proceed with your flow.     echo \'Yay!\'; } else {     // We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.     echo \'Hmm.... it is suspicious\'; }   ```  ``` javascript const crypto = require(\'crypto\'); const API_SECRET = \"<YOUR_API_SECRET>\"; // This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload. let payload = \'{}\'; // Assign the actual payload here const airaloSignature = \"<AIRALO_SIGNATURE>\"; // Assign the actual header here, located in key `airalo-signature` if (typeof payload === \'object\') {     payload = JSON.stringify(payload); } const expectedSignature = crypto.createHmac(\'sha512\', API_SECRET).update(payload).digest(\'hex\'); if (expectedSignature === airaloSignature) {     // Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.     // You can safely proceed with your flow.     console.log(\'Yay!\'); } else {     // We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.     console.log(\'Hmm.... it is suspicious\'); }   ```  ``` python import hashlib import hmac import json API_SECRET = \"<YOUR_API_SECRET>\" # This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload. # Assign the actual payload here payload = {     \"foo\": \"bar\",     \"baz:\": \"mqu\", }  # Replace with the actual payload # Assign the actual header here, located in key `airalo-signature` airalo_signature = \"<AIRALO_SIGNATURE>\" if isinstance(payload, dict):     payload = json.dumps(payload, separators=(\',\', \':\')) expected_signature = hmac.new(bytes(API_SECRET, \'utf-8\'), msg=bytes(payload, \'utf-8\'), digestmod=hashlib.sha512).hexdigest() if hmac.compare_digest(expected_signature, airalo_signature):     # Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.     # You can safely proceed with your flow.     print(\'Yay!\') else:     # We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.     print(\'Hmm.... it is suspicious\')   ```  ``` java import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.util.Base64; public class AiraloWebhookVerification {     private static final String API_SECRET = \"<YOUR_API_SECRET>\";     public static void main(String[] args) {         // This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload.         // Assign the actual payload here         String payload = \"{}\";  // Replace with the actual payload         // Assign the actual header here, located in key `airalo-signature`         String airaloSignature = \"<AIRALO_SIGNATURE>\";         if (payload instanceof String) {             try {                 MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");                 byte[] hash = digest.digest(payload.getBytes(StandardCharsets.UTF_8));                 payload = bytesToHex(hash);             } catch (NoSuchAlgorithmException e) {                 e.printStackTrace();             }         }         String expectedSignature = generateHmacSHA512(API_SECRET, payload);         if (expectedSignature.equals(airaloSignature)) {             // Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.             // You can safely proceed with your flow.             System.out.println(\"Yay!\");         } else {             // We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.             System.out.println(\"Hmm.... it is suspicious\");         }     }     private static String generateHmacSHA512(String key, String data) {         try {             Mac sha512_HMAC = Mac.getInstance(\"HmacSHA512\");             SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), \"HmacSHA512\");             sha512_HMAC.init(secret_key);             byte[] bytes = sha512_HMAC.doFinal(data.getBytes(StandardCharsets.UTF_8));             return bytesToHex(bytes);         } catch (Exception e) {             e.printStackTrace();             return null;         }     }     private static String bytesToHex(byte[] bytes) {         StringBuilder result = new StringBuilder();         for (byte b : bytes) {             result.append(String.format(\"x\", b));         }         return result.toString();     } }   ```
         * @summary Webhook definition
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootPost(contentType: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootPost(contentType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RESTAPIEndpointsNotificationsApi.rootPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows you to retrieve the details of low data notification from the Airalo Partners API. The access token, obtained from the \"Request Access Token\" endpoint, should be included in the request.  For more informations, best practices visit our FAQ page: [https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ](https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ)
         * @summary Get low data notification
         * @param {string} accept 
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2NotificationsOptInGet(accept: string, authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2NotificationsOptInGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2NotificationsOptInGet(accept, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RESTAPIEndpointsNotificationsApi.v2NotificationsOptInGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receive notifications regarding your credit limit as it reaches specific thresholds. You have   the flexibility to opt-in for various levels based on your requirements. For instance, you can   choose to receive notifications at 90% of your credit limit or select multiple thresholds such   as 50%, 70%, and 90%. These notifications can be delivered either to your webhook or your   company email address.  **Parameters**  - \"type\": \"webhook_credit_limit\", - use this value to receive notification via webhook - \"email_credit_limit\" use this value to receive notification via email - \"webhook_url\": \"[https://example.com\"](https://example.com\") - in case of notification to be       delivered via your webhook implementation, provide your webhook       implementation url - “email” – email address is case of notification via company email address - “language” – “en” – in case of email based notification
         * @summary Credit limit notification
         * @param {string} accept 
         * @param {string} authorization 
         * @param {V2NotificationsOptInPostRequest} [v2NotificationsOptInPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2NotificationsOptInPost(accept: string, authorization: string, v2NotificationsOptInPostRequest?: V2NotificationsOptInPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2NotificationsOptInPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2NotificationsOptInPost(accept, authorization, v2NotificationsOptInPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RESTAPIEndpointsNotificationsApi.v2NotificationsOptInPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This feature allows you to opt out of notifications regarding low data usage depending upon the type passed in the request payload  For more informations, best practices visit our FAQ page: [https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ](https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ)
         * @summary Low data notification - opt out
         * @param {string} accept 
         * @param {string} authorization 
         * @param {V2NotificationsOptOutPostRequest} [v2NotificationsOptOutPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2NotificationsOptOutPost(accept: string, authorization: string, v2NotificationsOptOutPostRequest?: V2NotificationsOptOutPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2NotificationsOptOutPost(accept, authorization, v2NotificationsOptOutPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RESTAPIEndpointsNotificationsApi.v2NotificationsOptOutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * With this endpoint parthers can trigger a Low Data Notification webhook event with mock data to their opted-in wehbook url. This is useful during testing/integration phase where developers can test their server when receiving such events.  Parameters  - \"event\" - string **required**      - \"type\" - string **required**      - \"iccid\" - string **optional**       For more informations, best practices visit our FAQ page: [https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ](https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ)
         * @summary Webhook simulator
         * @param {string} authorization 
         * @param {V2SimulatorWebhookPostRequest} [v2SimulatorWebhookPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2SimulatorWebhookPost(authorization: string, v2SimulatorWebhookPostRequest?: V2SimulatorWebhookPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V2SimulatorWebhookPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2SimulatorWebhookPost(authorization, v2SimulatorWebhookPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RESTAPIEndpointsNotificationsApi.v2SimulatorWebhookPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RESTAPIEndpointsNotificationsApi - factory interface
 * @export
 */
export const RESTAPIEndpointsNotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RESTAPIEndpointsNotificationsApiFp(configuration)
    return {
        /**
         * A webhook is a method in the context of Airalo\'s API, which serves as a means to seamlessly push real-time data updates to our partner\'s designated endpoint URL. This functionality ensures timely and efficient data synchronization between our systems and those of our valued partners.  **NOTE: Whenever an optin is performed, the webhook_url parameter is checked by the system via HEAD request, to which it must respond with 200 OK to be considered successful**  There are three types:   \\- _**Credit Limit Notification**_   \\- _**Low Data Notification**_ \\- _**Async Order**_  ### Custom Header for Payload Signing  To enhance the security and integrity of transmitted data, our webhook implementation includes a custom header for payload signing which is a HMAC value with sha512 algorithm. Partners are _**strongly encouraged**_ to include this header in their requests to validate the authenticity and integrity of the payload.  Header name: `airalo-signature`  **Examples on how to verify the integrity of the received webhook event:**  ``` php function calculateHMAC($data, $key) {     return hash_hmac(\'sha512\', $data, $key); } // Your API secret define(\"API_SECRET\", \"<YOUR_API_SECRET>\"); // This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload. $payload = []; // Assign the actual payload here $airaloSignature = \"<AIRALO_SIGNATURE>\"; // Assign the actual header here, located in key `airalo-signature` // Check if the payload is an object, if so, convert it to a JSON string if (is_array($payload) || is_object($payload)) {     $payload = json_encode($payload); } // Calculate the expected signature using HMAC with SHA512 $expectedSignature = calculateHMAC($payload, API_SECRET); if ($expectedSignature === $airaloSignature) {     // Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.     // You can safely proceed with your flow.     echo \'Yay!\'; } else {     // We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.     echo \'Hmm.... it is suspicious\'; }   ```  ``` javascript const crypto = require(\'crypto\'); const API_SECRET = \"<YOUR_API_SECRET>\"; // This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload. let payload = \'{}\'; // Assign the actual payload here const airaloSignature = \"<AIRALO_SIGNATURE>\"; // Assign the actual header here, located in key `airalo-signature` if (typeof payload === \'object\') {     payload = JSON.stringify(payload); } const expectedSignature = crypto.createHmac(\'sha512\', API_SECRET).update(payload).digest(\'hex\'); if (expectedSignature === airaloSignature) {     // Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.     // You can safely proceed with your flow.     console.log(\'Yay!\'); } else {     // We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.     console.log(\'Hmm.... it is suspicious\'); }   ```  ``` python import hashlib import hmac import json API_SECRET = \"<YOUR_API_SECRET>\" # This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload. # Assign the actual payload here payload = {     \"foo\": \"bar\",     \"baz:\": \"mqu\", }  # Replace with the actual payload # Assign the actual header here, located in key `airalo-signature` airalo_signature = \"<AIRALO_SIGNATURE>\" if isinstance(payload, dict):     payload = json.dumps(payload, separators=(\',\', \':\')) expected_signature = hmac.new(bytes(API_SECRET, \'utf-8\'), msg=bytes(payload, \'utf-8\'), digestmod=hashlib.sha512).hexdigest() if hmac.compare_digest(expected_signature, airalo_signature):     # Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.     # You can safely proceed with your flow.     print(\'Yay!\') else:     # We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.     print(\'Hmm.... it is suspicious\')   ```  ``` java import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.util.Base64; public class AiraloWebhookVerification {     private static final String API_SECRET = \"<YOUR_API_SECRET>\";     public static void main(String[] args) {         // This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload.         // Assign the actual payload here         String payload = \"{}\";  // Replace with the actual payload         // Assign the actual header here, located in key `airalo-signature`         String airaloSignature = \"<AIRALO_SIGNATURE>\";         if (payload instanceof String) {             try {                 MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");                 byte[] hash = digest.digest(payload.getBytes(StandardCharsets.UTF_8));                 payload = bytesToHex(hash);             } catch (NoSuchAlgorithmException e) {                 e.printStackTrace();             }         }         String expectedSignature = generateHmacSHA512(API_SECRET, payload);         if (expectedSignature.equals(airaloSignature)) {             // Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.             // You can safely proceed with your flow.             System.out.println(\"Yay!\");         } else {             // We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.             System.out.println(\"Hmm.... it is suspicious\");         }     }     private static String generateHmacSHA512(String key, String data) {         try {             Mac sha512_HMAC = Mac.getInstance(\"HmacSHA512\");             SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), \"HmacSHA512\");             sha512_HMAC.init(secret_key);             byte[] bytes = sha512_HMAC.doFinal(data.getBytes(StandardCharsets.UTF_8));             return bytesToHex(bytes);         } catch (Exception e) {             e.printStackTrace();             return null;         }     }     private static String bytesToHex(byte[] bytes) {         StringBuilder result = new StringBuilder();         for (byte b : bytes) {             result.append(String.format(\"x\", b));         }         return result.toString();     } }   ```
         * @summary Webhook definition
         * @param {RESTAPIEndpointsNotificationsApiRootPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootPost(requestParameters: RESTAPIEndpointsNotificationsApiRootPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.rootPost(requestParameters.contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve the details of low data notification from the Airalo Partners API. The access token, obtained from the \"Request Access Token\" endpoint, should be included in the request.  For more informations, best practices visit our FAQ page: [https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ](https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ)
         * @summary Get low data notification
         * @param {RESTAPIEndpointsNotificationsApiV2NotificationsOptInGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2NotificationsOptInGet(requestParameters: RESTAPIEndpointsNotificationsApiV2NotificationsOptInGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2NotificationsOptInGet200Response> {
            return localVarFp.v2NotificationsOptInGet(requestParameters.accept, requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Receive notifications regarding your credit limit as it reaches specific thresholds. You have   the flexibility to opt-in for various levels based on your requirements. For instance, you can   choose to receive notifications at 90% of your credit limit or select multiple thresholds such   as 50%, 70%, and 90%. These notifications can be delivered either to your webhook or your   company email address.  **Parameters**  - \"type\": \"webhook_credit_limit\", - use this value to receive notification via webhook - \"email_credit_limit\" use this value to receive notification via email - \"webhook_url\": \"[https://example.com\"](https://example.com\") - in case of notification to be       delivered via your webhook implementation, provide your webhook       implementation url - “email” – email address is case of notification via company email address - “language” – “en” – in case of email based notification
         * @summary Credit limit notification
         * @param {RESTAPIEndpointsNotificationsApiV2NotificationsOptInPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2NotificationsOptInPost(requestParameters: RESTAPIEndpointsNotificationsApiV2NotificationsOptInPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2NotificationsOptInPost200Response> {
            return localVarFp.v2NotificationsOptInPost(requestParameters.accept, requestParameters.authorization, requestParameters.v2NotificationsOptInPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This feature allows you to opt out of notifications regarding low data usage depending upon the type passed in the request payload  For more informations, best practices visit our FAQ page: [https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ](https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ)
         * @summary Low data notification - opt out
         * @param {RESTAPIEndpointsNotificationsApiV2NotificationsOptOutPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2NotificationsOptOutPost(requestParameters: RESTAPIEndpointsNotificationsApiV2NotificationsOptOutPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v2NotificationsOptOutPost(requestParameters.accept, requestParameters.authorization, requestParameters.v2NotificationsOptOutPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * With this endpoint parthers can trigger a Low Data Notification webhook event with mock data to their opted-in wehbook url. This is useful during testing/integration phase where developers can test their server when receiving such events.  Parameters  - \"event\" - string **required**      - \"type\" - string **required**      - \"iccid\" - string **optional**       For more informations, best practices visit our FAQ page: [https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ](https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ)
         * @summary Webhook simulator
         * @param {RESTAPIEndpointsNotificationsApiV2SimulatorWebhookPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SimulatorWebhookPost(requestParameters: RESTAPIEndpointsNotificationsApiV2SimulatorWebhookPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2SimulatorWebhookPost200Response> {
            return localVarFp.v2SimulatorWebhookPost(requestParameters.authorization, requestParameters.v2SimulatorWebhookPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RESTAPIEndpointsNotificationsApi - interface
 * @export
 * @interface RESTAPIEndpointsNotificationsApi
 */
export interface RESTAPIEndpointsNotificationsApiInterface {
    /**
     * A webhook is a method in the context of Airalo\'s API, which serves as a means to seamlessly push real-time data updates to our partner\'s designated endpoint URL. This functionality ensures timely and efficient data synchronization between our systems and those of our valued partners.  **NOTE: Whenever an optin is performed, the webhook_url parameter is checked by the system via HEAD request, to which it must respond with 200 OK to be considered successful**  There are three types:   \\- _**Credit Limit Notification**_   \\- _**Low Data Notification**_ \\- _**Async Order**_  ### Custom Header for Payload Signing  To enhance the security and integrity of transmitted data, our webhook implementation includes a custom header for payload signing which is a HMAC value with sha512 algorithm. Partners are _**strongly encouraged**_ to include this header in their requests to validate the authenticity and integrity of the payload.  Header name: `airalo-signature`  **Examples on how to verify the integrity of the received webhook event:**  ``` php function calculateHMAC($data, $key) {     return hash_hmac(\'sha512\', $data, $key); } // Your API secret define(\"API_SECRET\", \"<YOUR_API_SECRET>\"); // This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload. $payload = []; // Assign the actual payload here $airaloSignature = \"<AIRALO_SIGNATURE>\"; // Assign the actual header here, located in key `airalo-signature` // Check if the payload is an object, if so, convert it to a JSON string if (is_array($payload) || is_object($payload)) {     $payload = json_encode($payload); } // Calculate the expected signature using HMAC with SHA512 $expectedSignature = calculateHMAC($payload, API_SECRET); if ($expectedSignature === $airaloSignature) {     // Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.     // You can safely proceed with your flow.     echo \'Yay!\'; } else {     // We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.     echo \'Hmm.... it is suspicious\'; }   ```  ``` javascript const crypto = require(\'crypto\'); const API_SECRET = \"<YOUR_API_SECRET>\"; // This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload. let payload = \'{}\'; // Assign the actual payload here const airaloSignature = \"<AIRALO_SIGNATURE>\"; // Assign the actual header here, located in key `airalo-signature` if (typeof payload === \'object\') {     payload = JSON.stringify(payload); } const expectedSignature = crypto.createHmac(\'sha512\', API_SECRET).update(payload).digest(\'hex\'); if (expectedSignature === airaloSignature) {     // Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.     // You can safely proceed with your flow.     console.log(\'Yay!\'); } else {     // We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.     console.log(\'Hmm.... it is suspicious\'); }   ```  ``` python import hashlib import hmac import json API_SECRET = \"<YOUR_API_SECRET>\" # This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload. # Assign the actual payload here payload = {     \"foo\": \"bar\",     \"baz:\": \"mqu\", }  # Replace with the actual payload # Assign the actual header here, located in key `airalo-signature` airalo_signature = \"<AIRALO_SIGNATURE>\" if isinstance(payload, dict):     payload = json.dumps(payload, separators=(\',\', \':\')) expected_signature = hmac.new(bytes(API_SECRET, \'utf-8\'), msg=bytes(payload, \'utf-8\'), digestmod=hashlib.sha512).hexdigest() if hmac.compare_digest(expected_signature, airalo_signature):     # Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.     # You can safely proceed with your flow.     print(\'Yay!\') else:     # We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.     print(\'Hmm.... it is suspicious\')   ```  ``` java import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.util.Base64; public class AiraloWebhookVerification {     private static final String API_SECRET = \"<YOUR_API_SECRET>\";     public static void main(String[] args) {         // This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload.         // Assign the actual payload here         String payload = \"{}\";  // Replace with the actual payload         // Assign the actual header here, located in key `airalo-signature`         String airaloSignature = \"<AIRALO_SIGNATURE>\";         if (payload instanceof String) {             try {                 MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");                 byte[] hash = digest.digest(payload.getBytes(StandardCharsets.UTF_8));                 payload = bytesToHex(hash);             } catch (NoSuchAlgorithmException e) {                 e.printStackTrace();             }         }         String expectedSignature = generateHmacSHA512(API_SECRET, payload);         if (expectedSignature.equals(airaloSignature)) {             // Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.             // You can safely proceed with your flow.             System.out.println(\"Yay!\");         } else {             // We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.             System.out.println(\"Hmm.... it is suspicious\");         }     }     private static String generateHmacSHA512(String key, String data) {         try {             Mac sha512_HMAC = Mac.getInstance(\"HmacSHA512\");             SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), \"HmacSHA512\");             sha512_HMAC.init(secret_key);             byte[] bytes = sha512_HMAC.doFinal(data.getBytes(StandardCharsets.UTF_8));             return bytesToHex(bytes);         } catch (Exception e) {             e.printStackTrace();             return null;         }     }     private static String bytesToHex(byte[] bytes) {         StringBuilder result = new StringBuilder();         for (byte b : bytes) {             result.append(String.format(\"x\", b));         }         return result.toString();     } }   ```
     * @summary Webhook definition
     * @param {RESTAPIEndpointsNotificationsApiRootPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTAPIEndpointsNotificationsApiInterface
     */
    rootPost(requestParameters: RESTAPIEndpointsNotificationsApiRootPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * This endpoint allows you to retrieve the details of low data notification from the Airalo Partners API. The access token, obtained from the \"Request Access Token\" endpoint, should be included in the request.  For more informations, best practices visit our FAQ page: [https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ](https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ)
     * @summary Get low data notification
     * @param {RESTAPIEndpointsNotificationsApiV2NotificationsOptInGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTAPIEndpointsNotificationsApiInterface
     */
    v2NotificationsOptInGet(requestParameters: RESTAPIEndpointsNotificationsApiV2NotificationsOptInGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2NotificationsOptInGet200Response>;

    /**
     * Receive notifications regarding your credit limit as it reaches specific thresholds. You have   the flexibility to opt-in for various levels based on your requirements. For instance, you can   choose to receive notifications at 90% of your credit limit or select multiple thresholds such   as 50%, 70%, and 90%. These notifications can be delivered either to your webhook or your   company email address.  **Parameters**  - \"type\": \"webhook_credit_limit\", - use this value to receive notification via webhook - \"email_credit_limit\" use this value to receive notification via email - \"webhook_url\": \"[https://example.com\"](https://example.com\") - in case of notification to be       delivered via your webhook implementation, provide your webhook       implementation url - “email” – email address is case of notification via company email address - “language” – “en” – in case of email based notification
     * @summary Credit limit notification
     * @param {RESTAPIEndpointsNotificationsApiV2NotificationsOptInPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTAPIEndpointsNotificationsApiInterface
     */
    v2NotificationsOptInPost(requestParameters: RESTAPIEndpointsNotificationsApiV2NotificationsOptInPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2NotificationsOptInPost200Response>;

    /**
     * This feature allows you to opt out of notifications regarding low data usage depending upon the type passed in the request payload  For more informations, best practices visit our FAQ page: [https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ](https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ)
     * @summary Low data notification - opt out
     * @param {RESTAPIEndpointsNotificationsApiV2NotificationsOptOutPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTAPIEndpointsNotificationsApiInterface
     */
    v2NotificationsOptOutPost(requestParameters: RESTAPIEndpointsNotificationsApiV2NotificationsOptOutPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * With this endpoint parthers can trigger a Low Data Notification webhook event with mock data to their opted-in wehbook url. This is useful during testing/integration phase where developers can test their server when receiving such events.  Parameters  - \"event\" - string **required**      - \"type\" - string **required**      - \"iccid\" - string **optional**       For more informations, best practices visit our FAQ page: [https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ](https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ)
     * @summary Webhook simulator
     * @param {RESTAPIEndpointsNotificationsApiV2SimulatorWebhookPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTAPIEndpointsNotificationsApiInterface
     */
    v2SimulatorWebhookPost(requestParameters: RESTAPIEndpointsNotificationsApiV2SimulatorWebhookPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<V2SimulatorWebhookPost200Response>;

}

/**
 * Request parameters for rootPost operation in RESTAPIEndpointsNotificationsApi.
 * @export
 * @interface RESTAPIEndpointsNotificationsApiRootPostRequest
 */
export interface RESTAPIEndpointsNotificationsApiRootPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RESTAPIEndpointsNotificationsApiRootPost
     */
    readonly contentType: string
}

/**
 * Request parameters for v2NotificationsOptInGet operation in RESTAPIEndpointsNotificationsApi.
 * @export
 * @interface RESTAPIEndpointsNotificationsApiV2NotificationsOptInGetRequest
 */
export interface RESTAPIEndpointsNotificationsApiV2NotificationsOptInGetRequest {
    /**
     * 
     * @type {string}
     * @memberof RESTAPIEndpointsNotificationsApiV2NotificationsOptInGet
     */
    readonly accept: string

    /**
     * 
     * @type {string}
     * @memberof RESTAPIEndpointsNotificationsApiV2NotificationsOptInGet
     */
    readonly authorization: string
}

/**
 * Request parameters for v2NotificationsOptInPost operation in RESTAPIEndpointsNotificationsApi.
 * @export
 * @interface RESTAPIEndpointsNotificationsApiV2NotificationsOptInPostRequest
 */
export interface RESTAPIEndpointsNotificationsApiV2NotificationsOptInPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RESTAPIEndpointsNotificationsApiV2NotificationsOptInPost
     */
    readonly accept: string

    /**
     * 
     * @type {string}
     * @memberof RESTAPIEndpointsNotificationsApiV2NotificationsOptInPost
     */
    readonly authorization: string

    /**
     * 
     * @type {V2NotificationsOptInPostRequest}
     * @memberof RESTAPIEndpointsNotificationsApiV2NotificationsOptInPost
     */
    readonly v2NotificationsOptInPostRequest?: V2NotificationsOptInPostRequest
}

/**
 * Request parameters for v2NotificationsOptOutPost operation in RESTAPIEndpointsNotificationsApi.
 * @export
 * @interface RESTAPIEndpointsNotificationsApiV2NotificationsOptOutPostRequest
 */
export interface RESTAPIEndpointsNotificationsApiV2NotificationsOptOutPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RESTAPIEndpointsNotificationsApiV2NotificationsOptOutPost
     */
    readonly accept: string

    /**
     * 
     * @type {string}
     * @memberof RESTAPIEndpointsNotificationsApiV2NotificationsOptOutPost
     */
    readonly authorization: string

    /**
     * 
     * @type {V2NotificationsOptOutPostRequest}
     * @memberof RESTAPIEndpointsNotificationsApiV2NotificationsOptOutPost
     */
    readonly v2NotificationsOptOutPostRequest?: V2NotificationsOptOutPostRequest
}

/**
 * Request parameters for v2SimulatorWebhookPost operation in RESTAPIEndpointsNotificationsApi.
 * @export
 * @interface RESTAPIEndpointsNotificationsApiV2SimulatorWebhookPostRequest
 */
export interface RESTAPIEndpointsNotificationsApiV2SimulatorWebhookPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RESTAPIEndpointsNotificationsApiV2SimulatorWebhookPost
     */
    readonly authorization: string

    /**
     * 
     * @type {V2SimulatorWebhookPostRequest}
     * @memberof RESTAPIEndpointsNotificationsApiV2SimulatorWebhookPost
     */
    readonly v2SimulatorWebhookPostRequest?: V2SimulatorWebhookPostRequest
}

/**
 * RESTAPIEndpointsNotificationsApi - object-oriented interface
 * @export
 * @class RESTAPIEndpointsNotificationsApi
 * @extends {BaseAPI}
 */
export class RESTAPIEndpointsNotificationsApi extends BaseAPI implements RESTAPIEndpointsNotificationsApiInterface {
    /**
     * A webhook is a method in the context of Airalo\'s API, which serves as a means to seamlessly push real-time data updates to our partner\'s designated endpoint URL. This functionality ensures timely and efficient data synchronization between our systems and those of our valued partners.  **NOTE: Whenever an optin is performed, the webhook_url parameter is checked by the system via HEAD request, to which it must respond with 200 OK to be considered successful**  There are three types:   \\- _**Credit Limit Notification**_   \\- _**Low Data Notification**_ \\- _**Async Order**_  ### Custom Header for Payload Signing  To enhance the security and integrity of transmitted data, our webhook implementation includes a custom header for payload signing which is a HMAC value with sha512 algorithm. Partners are _**strongly encouraged**_ to include this header in their requests to validate the authenticity and integrity of the payload.  Header name: `airalo-signature`  **Examples on how to verify the integrity of the received webhook event:**  ``` php function calculateHMAC($data, $key) {     return hash_hmac(\'sha512\', $data, $key); } // Your API secret define(\"API_SECRET\", \"<YOUR_API_SECRET>\"); // This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload. $payload = []; // Assign the actual payload here $airaloSignature = \"<AIRALO_SIGNATURE>\"; // Assign the actual header here, located in key `airalo-signature` // Check if the payload is an object, if so, convert it to a JSON string if (is_array($payload) || is_object($payload)) {     $payload = json_encode($payload); } // Calculate the expected signature using HMAC with SHA512 $expectedSignature = calculateHMAC($payload, API_SECRET); if ($expectedSignature === $airaloSignature) {     // Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.     // You can safely proceed with your flow.     echo \'Yay!\'; } else {     // We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.     echo \'Hmm.... it is suspicious\'; }   ```  ``` javascript const crypto = require(\'crypto\'); const API_SECRET = \"<YOUR_API_SECRET>\"; // This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload. let payload = \'{}\'; // Assign the actual payload here const airaloSignature = \"<AIRALO_SIGNATURE>\"; // Assign the actual header here, located in key `airalo-signature` if (typeof payload === \'object\') {     payload = JSON.stringify(payload); } const expectedSignature = crypto.createHmac(\'sha512\', API_SECRET).update(payload).digest(\'hex\'); if (expectedSignature === airaloSignature) {     // Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.     // You can safely proceed with your flow.     console.log(\'Yay!\'); } else {     // We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.     console.log(\'Hmm.... it is suspicious\'); }   ```  ``` python import hashlib import hmac import json API_SECRET = \"<YOUR_API_SECRET>\" # This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload. # Assign the actual payload here payload = {     \"foo\": \"bar\",     \"baz:\": \"mqu\", }  # Replace with the actual payload # Assign the actual header here, located in key `airalo-signature` airalo_signature = \"<AIRALO_SIGNATURE>\" if isinstance(payload, dict):     payload = json.dumps(payload, separators=(\',\', \':\')) expected_signature = hmac.new(bytes(API_SECRET, \'utf-8\'), msg=bytes(payload, \'utf-8\'), digestmod=hashlib.sha512).hexdigest() if hmac.compare_digest(expected_signature, airalo_signature):     # Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.     # You can safely proceed with your flow.     print(\'Yay!\') else:     # We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.     print(\'Hmm.... it is suspicious\')   ```  ``` java import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.util.Base64; public class AiraloWebhookVerification {     private static final String API_SECRET = \"<YOUR_API_SECRET>\";     public static void main(String[] args) {         // This is the JSON payload pushed by Airalo\'s webhook. Depending on the framework you are using, retrieve the payload.         // Assign the actual payload here         String payload = \"{}\";  // Replace with the actual payload         // Assign the actual header here, located in key `airalo-signature`         String airaloSignature = \"<AIRALO_SIGNATURE>\";         if (payload instanceof String) {             try {                 MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");                 byte[] hash = digest.digest(payload.getBytes(StandardCharsets.UTF_8));                 payload = bytesToHex(hash);             } catch (NoSuchAlgorithmException e) {                 e.printStackTrace();             }         }         String expectedSignature = generateHmacSHA512(API_SECRET, payload);         if (expectedSignature.equals(airaloSignature)) {             // Here you are guaranteed the payload came from Airalo\'s system, and it is not from any third party or attacker.             // You can safely proceed with your flow.             System.out.println(\"Yay!\");         } else {             // We wouldn\'t trust this payload and the system that sent it... Better to reject it or proceed at your own risk.             System.out.println(\"Hmm.... it is suspicious\");         }     }     private static String generateHmacSHA512(String key, String data) {         try {             Mac sha512_HMAC = Mac.getInstance(\"HmacSHA512\");             SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), \"HmacSHA512\");             sha512_HMAC.init(secret_key);             byte[] bytes = sha512_HMAC.doFinal(data.getBytes(StandardCharsets.UTF_8));             return bytesToHex(bytes);         } catch (Exception e) {             e.printStackTrace();             return null;         }     }     private static String bytesToHex(byte[] bytes) {         StringBuilder result = new StringBuilder();         for (byte b : bytes) {             result.append(String.format(\"x\", b));         }         return result.toString();     } }   ```
     * @summary Webhook definition
     * @param {RESTAPIEndpointsNotificationsApiRootPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTAPIEndpointsNotificationsApi
     */
    public rootPost(requestParameters: RESTAPIEndpointsNotificationsApiRootPostRequest, options?: RawAxiosRequestConfig) {
        return RESTAPIEndpointsNotificationsApiFp(this.configuration).rootPost(requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to retrieve the details of low data notification from the Airalo Partners API. The access token, obtained from the \"Request Access Token\" endpoint, should be included in the request.  For more informations, best practices visit our FAQ page: [https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ](https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ)
     * @summary Get low data notification
     * @param {RESTAPIEndpointsNotificationsApiV2NotificationsOptInGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTAPIEndpointsNotificationsApi
     */
    public v2NotificationsOptInGet(requestParameters: RESTAPIEndpointsNotificationsApiV2NotificationsOptInGetRequest, options?: RawAxiosRequestConfig) {
        return RESTAPIEndpointsNotificationsApiFp(this.configuration).v2NotificationsOptInGet(requestParameters.accept, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receive notifications regarding your credit limit as it reaches specific thresholds. You have   the flexibility to opt-in for various levels based on your requirements. For instance, you can   choose to receive notifications at 90% of your credit limit or select multiple thresholds such   as 50%, 70%, and 90%. These notifications can be delivered either to your webhook or your   company email address.  **Parameters**  - \"type\": \"webhook_credit_limit\", - use this value to receive notification via webhook - \"email_credit_limit\" use this value to receive notification via email - \"webhook_url\": \"[https://example.com\"](https://example.com\") - in case of notification to be       delivered via your webhook implementation, provide your webhook       implementation url - “email” – email address is case of notification via company email address - “language” – “en” – in case of email based notification
     * @summary Credit limit notification
     * @param {RESTAPIEndpointsNotificationsApiV2NotificationsOptInPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTAPIEndpointsNotificationsApi
     */
    public v2NotificationsOptInPost(requestParameters: RESTAPIEndpointsNotificationsApiV2NotificationsOptInPostRequest, options?: RawAxiosRequestConfig) {
        return RESTAPIEndpointsNotificationsApiFp(this.configuration).v2NotificationsOptInPost(requestParameters.accept, requestParameters.authorization, requestParameters.v2NotificationsOptInPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This feature allows you to opt out of notifications regarding low data usage depending upon the type passed in the request payload  For more informations, best practices visit our FAQ page: [https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ](https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ)
     * @summary Low data notification - opt out
     * @param {RESTAPIEndpointsNotificationsApiV2NotificationsOptOutPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTAPIEndpointsNotificationsApi
     */
    public v2NotificationsOptOutPost(requestParameters: RESTAPIEndpointsNotificationsApiV2NotificationsOptOutPostRequest, options?: RawAxiosRequestConfig) {
        return RESTAPIEndpointsNotificationsApiFp(this.configuration).v2NotificationsOptOutPost(requestParameters.accept, requestParameters.authorization, requestParameters.v2NotificationsOptOutPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * With this endpoint parthers can trigger a Low Data Notification webhook event with mock data to their opted-in wehbook url. This is useful during testing/integration phase where developers can test their server when receiving such events.  Parameters  - \"event\" - string **required**      - \"type\" - string **required**      - \"iccid\" - string **optional**       For more informations, best practices visit our FAQ page: [https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ](https://airalopartners.zendesk.com/hc/en-us/sections/13207524820893-FAQ)
     * @summary Webhook simulator
     * @param {RESTAPIEndpointsNotificationsApiV2SimulatorWebhookPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RESTAPIEndpointsNotificationsApi
     */
    public v2SimulatorWebhookPost(requestParameters: RESTAPIEndpointsNotificationsApiV2SimulatorWebhookPostRequest, options?: RawAxiosRequestConfig) {
        return RESTAPIEndpointsNotificationsApiFp(this.configuration).v2SimulatorWebhookPost(requestParameters.authorization, requestParameters.v2SimulatorWebhookPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

