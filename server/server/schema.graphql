# eSIM Go GraphQL Schema
# Main schema file for the eSIM Go platform

type Query {
  # Basic hello query for testing
  hello: String!

  # User authentication and profile
  me: User @auth
  users: [User!]! @auth(role: "ADMIN")
  orders: [Order!]! @auth(role: "ADMIN")

  # eSIM queries
  myESIMs: [ESIM!]! @auth
  esimDetails(id: ID!): ESIM @auth

  dataPlans(filter: DataPlanFilter): DataPlanConnection!
  dataPlan(id: ID!): DataPlan

  # Order queries
  myOrders(filter: OrderFilter): [Order!]! @auth
  orderDetails(id: ID!): Order @auth
  getUserOrders(userId: ID!): [Order!]! @auth(role: "ADMIN")

  countries: [Country!]!
  trips: [Trip!]!

  # Calculate price
  calculatePrice(numOfDays: Int!, regionId: String!, countryId: String!, paymentMethod: PaymentMethod): PricingBreakdown!
  
  # Batch calculate prices for multiple bundles
  calculatePrices(inputs: [CalculatePriceInput!]!): [PricingBreakdown!]!
  
  # Bundles grouped by country with aggregated pricing data
  bundlesByCountry: [BundlesByCountry!]!
  
  # Get bundles for a specific country
  countryBundles(countryId: String!): [CountryBundle!]!
  
  # Pricing configurations
  pricingConfigurations: [PricingConfiguration!]!
  
  # Processing fee configurations
  currentProcessingFeeConfiguration: ProcessingFeeConfiguration @auth(role: "ADMIN")
  processingFeeConfigurations(limit: Int = 10, offset: Int = 0, includeInactive: Boolean = false): [ProcessingFeeConfiguration!]! @auth(role: "ADMIN")
  processingFeeConfiguration(id: ID!): ProcessingFeeConfiguration @auth(role: "ADMIN")
  
  # Markup configurations
  markupConfig: [MarkupConfig!]! @auth(role: "ADMIN")
}

type Mutation {
  # Authentication
  signIn(input: SignInInput!): SignInResponse
  signUp(input: SignUpInput!): SignUpResponse

  # Social Authentication
  signInWithApple(input: SocialSignInInput!): SignInResponse
  signInWithGoogle(input: SocialSignInInput!): SignInResponse

  # Phone Authentication
  sendPhoneOTP(phoneNumber: String!): SendOTPResponse
  verifyPhoneOTP(input: VerifyOTPInput!): SignInResponse

  # User Management
  updateUserRole(userId: ID!, role: String!): User @auth(role: "ADMIN")
  inviteAdminUser(input: InviteAdminUserInput!): InviteAdminUserResponse @auth(role: "ADMIN")
  deleteUser(userId: ID!): DeleteUserResponse @auth(role: "ADMIN")

  # Trip Management
  createTrip(input: CreateTripInput!): CreateTripResponse @auth(role: "ADMIN")
  updateTrip(input: UpdateTripInput!): UpdateTripResponse @auth(role: "ADMIN")
  deleteTrip(id: ID!): DeleteTripResponse @auth(role: "ADMIN")
  
  # Pricing configuration management
  updatePricingConfiguration(input: UpdatePricingConfigurationInput!): UpdatePricingConfigurationResponse @auth(role: "ADMIN")
  
  # Processing fee configuration management
  createProcessingFeeConfiguration(input: ProcessingFeeConfigurationInput!): ProcessingFeeConfiguration @auth(role: "ADMIN")
  updateProcessingFeeConfiguration(id: ID!, input: ProcessingFeeConfigurationInput!): ProcessingFeeConfiguration @auth(role: "ADMIN")
  deactivateProcessingFeeConfiguration(id: ID!): ProcessingFeeConfiguration @auth(role: "ADMIN")
  
  # Markup configuration management
  createMarkupConfig(input: CreateMarkupConfigInput!): MarkupConfig @auth(role: "ADMIN")
  updateMarkupConfig(id: ID!, input: UpdateMarkupConfigInput!): MarkupConfig @auth(role: "ADMIN")
  deleteMarkupConfig(id: ID!): DeleteMarkupConfigResponse @auth(role: "ADMIN")
  
  # Package Assignment
  assignPackageToUser(userId: ID!, planId: ID!): AssignPackageResponse @auth(role: "ADMIN")

  # eSIM operations
  purchaseESIM(planId: ID!, input: PurchaseESIMInput!): PurchaseESIMResponse
    @auth
  activateESIM(esimId: ID!): ActivateESIMResponse @auth
  suspendESIM(esimId: ID!): ESIMActionResponse @auth
  restoreESIM(esimId: ID!): ESIMActionResponse @auth
  cancelESIM(esimId: ID!): ESIMActionResponse @auth
  updateESIMReference(esimId: ID!, reference: String!): ESIMActionResponse @auth
}

type Subscription {
  # Real-time eSIM status updates
  esimStatusUpdated(esimId: ID!): ESIMStatusUpdate! @auth
}

# User Types
type User {
  id: ID!
  email: String!
  firstName: String!
  lastName: String!
  phoneNumber: String
  role: String!
  createdAt: String!
  updatedAt: String!
  orderCount: Int!
}

type Country {
  iso: ISOCountryCode! # ISO 3166-1 alpha-2 code
  name: String! # English name
  nameHebrew: String
  region: String!
  flag: String
}

type Trip {
  id: ID!
  name: String!
  description: String!
  regionId: String!
  countries: [Country!]!
  countryIds: [ISOCountryCode!]!
  createdAt: String!
  updatedAt: String!
  createdBy: String
}

# Authentication Types
input SignInInput {
  email: String!
  password: String!
}

input SignUpInput {
  email: String!
  password: String!
  firstName: String!
  lastName: String!
  phoneNumber: String
}

# Social Authentication
input SocialSignInInput {
  idToken: String! # JWT token from Apple/Google
  firstName: String # For first-time users
  lastName: String # For first-time users
}

# Phone Authentication
input VerifyOTPInput {
  phoneNumber: String!
  otp: String!
  firstName: String # For first-time users
  lastName: String # For first-time users
}

type SendOTPResponse {
  success: Boolean!
  error: String
  messageId: String # For tracking SMS delivery
}

type SignInResponse {
  success: Boolean!
  user: User
  sessionToken: String
  refreshToken: String
  error: String
}

type SignUpResponse {
  success: Boolean!
  user: User
  sessionToken: String
  refreshToken: String
  error: String
}

# Admin Invitation Types
input InviteAdminUserInput {
  email: String!
  role: String!
  redirectUrl: String
}

type InviteAdminUserResponse {
  success: Boolean!
  error: String
  invitedEmail: String
}

type DeleteUserResponse {
  success: Boolean!
  error: String
}

# Trip Management Types
input CreateTripInput {
  name: String!
  description: String!
  regionId: String!
  countryIds: [ISOCountryCode!]!
}

input UpdateTripInput {
  id: ID!
  name: String!
  description: String!
  regionId: String!
  countryIds: [ISOCountryCode!]!
}

type CreateTripResponse {
  success: Boolean!
  error: String
  trip: Trip
}

type UpdateTripResponse {
  success: Boolean!
  error: String
  trip: Trip
}

type DeleteTripResponse {
  success: Boolean!
  error: String
}

# Package Assignment Types
type PackageAssignment {
  id: ID!
  user: User!
  dataPlan: DataPlan!
  assignedAt: String!
  assignedBy: User!
  status: AssignmentStatus!
  createdAt: String!
  updatedAt: String!
}

enum AssignmentStatus {
  PENDING
  ASSIGNED
  ACTIVATED
  EXPIRED
  CANCELLED
}

type AssignPackageResponse {
  success: Boolean!
  error: String
  assignment: PackageAssignment
}

# Data Plan Types (from eSIM Go catalogue)
type DataPlan {
  id: ID!
  name: String! # eSIM Go bundle name
  description: String!
  region: String!
  countries: [Country!]!
  duration: Int! # Duration in days
  price: Float! # Price in USD
  currency: String!
  isUnlimited: Boolean!
  bundleGroup: String
  features: [String!]!
  availableQuantity: Int
}

# Data plan filtering
input DataPlanFilter {
  region: String
  country: String # ISO code
  duration: Int # Days
  maxPrice: Float
  bundleGroup: String
  search: String # Search term for name/description
  limit: Int # Number of items per page (default: 50, max: 200)
  offset: Int # Starting position for pagination (default: 0)
}

# Pagination types for data plans
type DataPlanConnection {
  items: [DataPlan!]!
  totalCount: Int!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  pageInfo: PageInfo!
  lastFetched: String
}

type PageInfo {
  limit: Int!
  offset: Int!
  total: Int!
  pages: Int!
  currentPage: Int!
}

# Order Types
type Order {
  id: ID!
  reference: String! # eSIM Go order reference
  status: OrderStatus!
  dataPlan: DataPlan
  quantity: Int!
  totalPrice: Float!
  esims: [ESIM!]!
  user: User # User who placed the order
  createdAt: String!
  updatedAt: String!
}

enum OrderStatus {
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

input OrderFilter {
  status: OrderStatus
  fromDate: String
  toDate: String
}

# eSIM Types (updated)
type ESIM {
  id: ID!
  order: Order!
  plan: DataPlan!
  iccid: String! # eSIM identifier
  customerRef: String
  qrCode: String # QR code for eSIM installation
  status: ESIMStatus!
  assignedDate: String
  lastAction: String
  actionDate: String
  bundles: [ESIMBundle!]!
  usage: ESIMUsage!
  createdAt: String!
  updatedAt: String!
}

type ESIMBundle {
  id: ID!
  name: String!
  state: BundleState!
  dataUsed: Float! # MB used
  dataRemaining: Float # MB remaining (null for unlimited)
  startDate: String
  endDate: String
}

enum BundleState {
  PROCESSING
  ACTIVE
  INACTIVE
  SUSPENDED
  EXPIRED
  CANCELLED
}

type ESIMUsage {
  totalUsed: Float! # Total MB used
  totalRemaining: Float # Total MB remaining (null for unlimited)
  activeBundles: [ESIMBundle!]!
}

enum ESIMStatus {
  PROCESSING
  ASSIGNED
  ACTIVE
  SUSPENDED
  EXPIRED
  CANCELLED
}

# eSIM Operations
input PurchaseESIMInput {
  quantity: Int!
  customerReference: String
  autoActivate: Boolean
}

type PurchaseESIMResponse {
  success: Boolean!
  order: Order
  error: String
}

type ActivateESIMResponse {
  success: Boolean!
  esim: ESIM
  error: String
}

type ESIMActionResponse {
  success: Boolean!
  esim: ESIM
  error: String
}

type ESIMStatusUpdate {
  esimId: ID!
  status: ESIMStatus!
  dataUsed: Float
  dataRemaining: Float
  updatedAt: String!
}

# Basic checkout session type (enhanced)
type CheckoutSession {
  id: ID!
  token: String! # JWT token for secure navigation
  expiresAt: DateTime!
  isComplete: Boolean!
  timeRemaining: Int # seconds until expiration
  createdAt: DateTime!
  # Additional fields for frontend
  planSnapshot: JSON
  pricing: JSON
  steps: JSON
  paymentStatus: String
  metadata: JSON
  orderId: ID # Order ID after completion
}

# Input for creating a checkout session
input CreateCheckoutSessionInput {
  numOfDays: Int!
  regionId: String!
  countryId: String!
}

# Response types
type CreateCheckoutSessionResponse {
  success: Boolean!
  session: CheckoutSession
  error: String
}

type GetCheckoutSessionResponse {
  success: Boolean!
  session: CheckoutSession
  error: String
}

# Input for updating checkout steps
input UpdateCheckoutStepInput {
  token: String!
  stepType: CheckoutStepType!
  data: JSON! # Flexible data based on step type
}

# Response for step updates
type UpdateCheckoutStepResponse {
  success: Boolean!
  session: CheckoutSession
  nextStep: CheckoutStepType
  error: String
}

# Enum for step types
enum CheckoutStepType {
  AUTHENTICATION
  DELIVERY
  PAYMENT
}

# Input for processing final payment
input ProcessCheckoutPaymentInput {
  token: String!
  paymentMethodId: String! # From Stripe/payment provider
  savePaymentMethod: Boolean = false
}

# Response for payment processing
type ProcessCheckoutPaymentResponse {
  success: Boolean!
  orderId: ID
  session: CheckoutSession
  paymentIntentId: String
  webhookProcessing: Boolean # Indicates webhook is handling completion
  error: String
}

extend type Query {
  getCheckoutSession(token: String!): GetCheckoutSessionResponse!
}

extend type Mutation {
  createCheckoutSession(
    input: CreateCheckoutSessionInput!
  ): CreateCheckoutSessionResponse!
  updateCheckoutStep(
    input: UpdateCheckoutStepInput!
  ): UpdateCheckoutStepResponse!
  processCheckoutPayment(
    input: ProcessCheckoutPaymentInput!
  ): ProcessCheckoutPaymentResponse!
  validateOrder(
    input: ValidateOrderInput!
  ): ValidateOrderResponse!
}

# Pricing Types
type PricingBreakdown {
  # Bundle Information
  bundleName: String!
  countryName: String!
  duration: Int!
  
  # Base Costs (configured values)
  cost: Float!
  costPlus: Float!
  totalCost: Float!
  
  # Discount Configuration
  discountRate: Float! # percentage (e.g., 0.30 for 30%)
  discountValue: Float! # computed: totalCost * discountRate
  priceAfterDiscount: Float! # computed: totalCost - discountValue
  
  # Processing Fees
  processingRate: Float! # percentage (e.g., 0.045 for 4.5%)
  processingCost: Float! # computed: priceAfterDiscount * processingRate
  
  # Final Revenue & Profit
  finalRevenue: Float! # computed: priceAfterDiscount - processingCost (what we actually receive)
  netProfit: Float! # computed: finalRevenue - totalCost (profit after all costs)
  
  # Currency
  currency: String!
}

# Bundles by Country Types - aggregated pricing data for countries
type BundlesByCountry {
  countryName: String!
  countryId: String!
  totalBundles: Int!
  avgPricePerDay: Float!
  hasCustomDiscount: Boolean!
  avgDiscountRate: Float!
  totalDiscountValue: Float!
  avgCost: Float!
  avgCostPlus: Float!
  avgTotalCost: Float!
  avgProcessingRate: Float!
  avgProcessingCost: Float!
  avgFinalRevenue: Float!
  avgNetProfit: Float!
  totalRevenue: Float!
  avgProfitMargin: Float!
  lastFetched: String
  calculationMethod: String! # SAMPLED | ESTIMATED
}

# Individual bundles for a specific country
type CountryBundle {
  bundleName: String!
  countryName: String!
  countryId: String!
  duration: Int!
  cost: Float!
  costPlus: Float!
  totalCost: Float!
  discountRate: Float!
  discountValue: Float!
  priceAfterDiscount: Float!
  processingRate: Float!
  processingCost: Float!
  finalRevenue: Float!
  netProfit: Float!
  currency: String!
  pricePerDay: Float!
  hasCustomDiscount: Boolean!
}

# Batch pricing input
input CalculatePriceInput {
  numOfDays: Int!
  regionId: String!
  countryId: String!
  paymentMethod: PaymentMethod
}

# Pricing Configuration Types
type PricingConfiguration {
  id: ID!
  name: String!
  description: String!
  
  # Bundle filters (null = applies to all)
  countryId: String
  regionId: String
  duration: Int
  bundleGroup: String
  
  # Configuration values
  costSplitPercent: Float! # What % of bundle price is base cost (default: 60%)
  discountRate: Float! # Discount percentage (default: 0%)
  processingRate: Float! # Processing fee percentage (default: 4.5%)
  
  # Metadata
  isActive: Boolean!
  priority: Int! # Higher priority overrides lower priority
  createdBy: String!
  createdAt: String!
  updatedAt: String!
}

input UpdatePricingConfigurationInput {
  id: ID # If provided, update existing; if null, create new
  name: String!
  description: String!
  
  # Bundle filters
  countryId: String
  regionId: String
  duration: Int
  bundleGroup: String
  
  # Configuration values
  costSplitPercent: Float!
  discountRate: Float!
  processingRate: Float!
  
  isActive: Boolean!
  priority: Int!
}

type UpdatePricingConfigurationResponse {
  success: Boolean!
  configuration: PricingConfiguration
  error: String
}

scalar ISOCountryCode
scalar DateTime
scalar JSON

# Payment method enum for processing fee calculation
enum PaymentMethod {
  ISRAELI_CARD
  FOREIGN_CARD
  BIT
  AMEX
  DINERS
}

# Processing Fee Configuration Types
type ProcessingFeeConfiguration {
  id: ID!
  # Main processing fees (percentages)
  israeliCardsRate: Float!           # עמלות סליקה עסקאות ש"ח בכרטיסים שהונפקו בישראל
  foreignCardsRate: Float!           # עמלות סליקה כרטיסים שהונפקו בחו"ל  
  premiumDinersRate: Float!          # תוספת דיינרס
  premiumAmexRate: Float!            # תוספת אמקס
  bitPaymentRate: Float!             # תוספת ביט
  
  # Fixed fees (amounts in ILS)
  fixedFeeNIS: Float!                # עמלה קבועה לעסקה בש"ח
  fixedFeeForeign: Float!            # עמלה קבועה לעסקה במט"ח
  monthlyFixedCost: Float!           # עלות חודשית קבועה
  bankWithdrawalFee: Float!          # עלות משיכה לחשבון הבנק
  monthlyMinimumFee: Float!          # עמלת מינימום חודשית
  setupCost: Float!                  # עלות הקמה
  
  # Additional services (amounts in ILS)
  threeDSecureFee: Float!            # 3DSecure
  chargebackFee: Float!              # עמלת הכחשות עסקה
  cancellationFee: Float!            # עמלת ביטול עסקה
  invoiceServiceFee: Float!          # שירותי חשבוניות
  appleGooglePayFee: Float!          # Apple/Google Pay
  
  # Metadata
  isActive: Boolean!                 # Whether this configuration is currently active
  effectiveFrom: DateTime!           # When this configuration becomes effective
  effectiveTo: DateTime              # When this configuration expires (null for current)
  createdAt: DateTime!
  updatedAt: DateTime!
  createdBy: String!                 # User who created this configuration
  notes: String                      # Optional notes about this configuration
}

# Input for creating/updating processing fee configuration
input ProcessingFeeConfigurationInput {
  israeliCardsRate: Float!
  foreignCardsRate: Float!
  premiumDinersRate: Float!
  premiumAmexRate: Float!
  bitPaymentRate: Float!
  fixedFeeNIS: Float!
  fixedFeeForeign: Float!
  monthlyFixedCost: Float!
  bankWithdrawalFee: Float!
  monthlyMinimumFee: Float!
  setupCost: Float!
  threeDSecureFee: Float!
  chargebackFee: Float!
  cancellationFee: Float!
  invoiceServiceFee: Float!
  appleGooglePayFee: Float!
  effectiveFrom: DateTime!
  effectiveTo: DateTime
  notes: String
}

# Markup Configuration Types
type MarkupConfig {
  id: ID!
  bundleGroup: String!              # Bundle group name (e.g., "Standard - Unlimited Essential")
  durationDays: Int!                # Duration in days
  markupAmount: Float!              # Fixed markup amount in USD
  createdAt: DateTime!
  updatedAt: DateTime!
}

# Input for creating markup configuration
input CreateMarkupConfigInput {
  bundleGroup: String!
  durationDays: Int!
  markupAmount: Float!
}

# Input for updating markup configuration
input UpdateMarkupConfigInput {
  bundleGroup: String
  durationDays: Int
  markupAmount: Float
}

# Response for delete operations
type DeleteMarkupConfigResponse {
  success: Boolean!
  message: String
}

# Order Validation Types
input ValidateOrderInput {
  bundleName: String!
  quantity: Int!
  customerReference: String
}

type ValidateOrderResponse {
  success: Boolean!
  isValid: Boolean!
  bundleDetails: JSON
  totalPrice: Float
  currency: String
  error: String
  errorCode: String
}
