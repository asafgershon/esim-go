type Query {
  # Basic hello query for testing
  hello: String!

  # User authentication and profile
  me: User @auth
  users: [User!]! @auth(role: "ADMIN")
  orders: [Order!]! @auth(role: "ADMIN")
  
  # Tenant management
  tenants: [Tenant!]! @auth
  
  # Master tenant queries
  allTenants(filter: TenantFilter, pagination: PaginationInput): TenantConnection! @auth
  tenant(slug: ID!): Tenant @auth

  # eSIM queries
  myESIMs: [ESIM!]! @auth
  esimDetails(id: ID!): ESIM @auth

  # Order queries
  myOrders(filter: OrderFilter): [Order!]! @auth
  orderDetails(id: ID!): Order @auth
  getUserOrders(userId: ID!): [Order!]! @auth(role: "ADMIN")

  countries: [Country!]!
  trips: [Trip!]!

  # Calculate price - Public access, sensitive fields protected at field level
  calculatePrice(input: CalculatePriceInput!): PricingBreakdown!

  # Batch calculate prices for multiple bundles
  calculatePrices(inputs: [CalculatePriceInput!]!): [PricingBreakdown!]!

  # Main bundles resolver with optional filtering
  bundle(id: String!): Bundle!
  # Search bundles with filtering and pagination
  bundles(filter: BundleFilter, pagination: PaginationInput): BundleConnection!

  bundlesByCountry(countryId: String): [BundlesByCountry!]!
  bundlesByRegion(regionId: String): [BundlesByRegion!]!
  bundlesByGroup(groupId: String): [BundlesByGroup!]!

  bundlesForCountry(countryCode: String!): BundlesForCountry
  bundlesForRegion(region: String!): BundlesForRegion
  bundlesForGroup(group: String!): BundlesForGroup

  # Pricing Rules Engine
  pricingRules(filter: PricingRuleFilter): [PricingRule!]!
  pricingRule(id: ID!): PricingRule
  activePricingRules: [PricingRule!]!
  conflictingPricingRules(ruleId: ID!): [PricingRule!]!
  simulatePricingRule(
    rule: CreatePricingRuleInput!
    testContext: TestPricingContext!
  ): PricingBreakdown!

  # Pricing filters
  pricingFilters: PricingFilters!

  # High demand countries
  highDemandCountries: [String!]! @auth(role: "ADMIN")
  
  # Payment methods with processing rates
  paymentMethods: [PaymentMethodInfo!]!

  # Catalog sync history
  catalogSyncHistory(params: SyncHistoryParams): CatalogSyncHistoryConnection!
    @auth(role: "ADMIN")

  # Catalog bundles queries (from new catalog system)
  catalogBundles(criteria: SearchCatalogCriteria): CatalogBundleConnection!
    @auth(role: "ADMIN")
  bundleFilterOptions: BundleFilterOptions!
  
  # Admin eSIM management queries
  getAllESIMs: [AdminESIM!]! @auth(role: "ADMIN")
  getCustomerESIMs(userId: ID!): [AdminESIM!]! @auth(role: "ADMIN")
  getAdminESIMDetails(iccid: String!): AdminESIMDetails! @auth(role: "ADMIN")
}

type BundleConnection {
  nodes: [Bundle!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type BundlesForCountry {
  """
  Country information
  """
  country: Country!

  """
  All bundles available for this country
  """
  bundles: [Bundle!]!

  """
  Total number of bundles
  """
  bundleCount: Int!

  """
  Price range
  """
  pricingRange: PriceRange!

  """
  Groups available in this country
  """
  groups: [String!]!

  """
  Regions that include this country
  """
  regions: [String!]!

  """
  Whether unlimited bundles are available
  """
  hasUnlimited: Boolean!
}

type BundlesForRegion {
  """
  Region name
  """
  region: String!

  """
  All bundles available for this region
  """
  bundles: [Bundle!]!

  """
  Total number of bundles
  """
  bundleCount: Int!

  """
  Price range
  """
  pricingRange: PriceRange!

  """
  Countries in this region
  """
  countries: [String!]!

  """
  Groups available in this region
  """
  groups: [String!]!

  """
  Whether unlimited bundles are available
  """
  hasUnlimited: Boolean!
}

type BundlesForGroup {
  """
  Group name
  """
  group: String!

  """
  All bundles in this group
  """
  bundles: [Bundle!]!

  """
  Total number of bundles
  """
  bundleCount: Int!

  """
  Price range
  """
  pricingRange: PriceRange!

  """
  Countries covered by this group
  """
  countries: [String!]!

  """
  Regions covered by this group
  """
  regions: [String!]!

  """
  Whether unlimited bundles are available
  """
  hasUnlimited: Boolean!
}

type PriceRange {
  """
  Minimum price
  """
  min: Float!

  """
  Maximum price
  """
  max: Float!

  """
  Average price (optional)
  """
  avg: Float

  """
  Currency code
  """
  currency: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

type FilterOption {
  value: String!
  label: String!
}

type BundleFilterOptions {
  groups: [FilterOption!]!
  countries: [FilterOption!]!
  regions: [FilterOption!]!
}

input BundleFilter {
  countries: [String!]
  groups: [String!]
  region: String
  isUnlimited: Boolean
  validityInDays: IntRange
  priceRange: FloatRange
}

input IntRange {
  min: Int
  max: Int
}

input FloatRange {
  min: Float
  max: Float
}

input PaginationInput {
  limit: Int = 50
  offset: Int = 0
}

type BundleFilterOptions {
  """
  Available groups
  """
  groups: [FilterOption!]!

  """
  Available countries
  """
  countries: [FilterOption!]!

  """
  Available regions
  """
  regions: [FilterOption!]!
}

type Mutation {
  # Authentication
  signIn(input: SignInInput!): SignInResponse
  signUp(input: SignUpInput!): SignUpResponse

  # Social Authentication
  signInWithApple(input: SocialSignInInput!): SignInResponse
  signInWithGoogle(input: SocialSignInInput!): SignInResponse

  # Phone Authentication
  sendPhoneOTP(phoneNumber: String!): SendOTPResponse
  verifyPhoneOTP(input: VerifyOTPInput!): SignInResponse

  # Profile Management
  updateProfile(input: UpdateProfileInput!): UpdateProfileResponse @auth

  # User Management
  updateUserRole(userId: ID!, role: String!): User @auth(role: "ADMIN")
  inviteAdminUser(input: InviteAdminUserInput!): InviteAdminUserResponse
    @auth(role: "ADMIN")
  deleteUser(userId: ID!): DeleteUserResponse @auth(role: "ADMIN")

  # Trip Management
  createTrip(input: CreateTripInput!): CreateTripResponse @auth(role: "ADMIN")
  updateTrip(input: UpdateTripInput!): UpdateTripResponse @auth(role: "ADMIN")
  deleteTrip(id: ID!): DeleteTripResponse @auth(role: "ADMIN")

  # Pricing configuration management
  updatePricingConfiguration(
    input: UpdatePricingConfigurationInput!
  ): UpdatePricingConfigurationResponse @auth(role: "ADMIN")

  # Package Assignment
  assignPackageToUser(userId: ID!, planId: ID!): AssignPackageResponse
    @auth(role: "ADMIN")


  # High demand countries management
  toggleHighDemandCountry(countryId: String!): ToggleHighDemandResponse
    @auth(role: "ADMIN")

  # Catalog sync operations (enhanced)
  triggerCatalogSync(params: TriggerSyncParams!): TriggerSyncResponse
    @auth(role: "ADMIN")

  # eSIM operations
  purchaseESIM(planId: ID!, input: PurchaseESIMInput!): PurchaseESIMResponse
    @auth
  activateESIM(esimId: ID!): ActivateESIMResponse @auth
  suspendESIM(esimId: ID!): ESIMActionResponse @auth
  restoreESIM(esimId: ID!): ESIMActionResponse @auth
  cancelESIM(esimId: ID!): ESIMActionResponse @auth
  updateESIMReference(esimId: ID!, reference: String!): ESIMActionResponse @auth
}

type Subscription {
  # Real-time eSIM status updates
  esimStatusUpdated(esimId: ID!): ESIMStatusUpdate! @auth

  # Catalog sync progress (admin only)
  catalogSyncProgress: CatalogSyncProgressUpdate! @auth(role: "ADMIN")

  # Pricing pipeline progress (authenticated users only)
  pricingPipelineProgress(correlationId: String!): PricingPipelineStepUpdate! @auth
}

interface Bundle {
  # Identification
  name: String!
  description: String
  groups: [String!]!

  # Duration and data
  validityInDays: Int!
  dataAmountMB: Int # null for unlimited
  dataAmountReadable: String! # "5GB", "Unlimited", etc.
  isUnlimited: Boolean!

  # Coverage
  countries: [String!]! # ISO country codes
  region: String

  # Network capabilities
  speed: [String!]! # ["3G", "4G", "5G"]
  # Base pricing (before any rules/markups)
  basePrice: Float!
  currency: String!
  
  # Calculated pricing (only computed when requested)
  pricingBreakdown(
    paymentMethod: PaymentMethod
  ): PricingBreakdown
}

type CatalogBundle implements Bundle {
  # Primary key
  esimGoName: ID!
  name: String!
  # Bundle interface fields
  description: String
  groups: [String!]!
  validityInDays: Int!
  dataAmountMB: Int
  dataAmountReadable: String!
  isUnlimited: Boolean!
  countries: [String!]!
  region: String
  speed: [String!]!
  basePrice: Float! # Maps to 'price' column in DB
  currency: String!
  
  # Calculated pricing (from Bundle interface)
  pricingBreakdown(
    paymentMethod: PaymentMethod
  ): PricingBreakdown

  # Timestamps
  createdAt: DateTime!
  updatedAt: DateTime!
  syncedAt: DateTime!
}

# Customer-facing bundle with pricing calculations
type CustomerBundle implements Bundle {
  id: ID!

  name: String!
  description: String
  groups: [String!]!
  validityInDays: Int!
  dataAmountMB: Int
  dataAmountReadable: String!
  isUnlimited: Boolean!
  countries: [String!]!
  region: String
  speed: [String!]!
  basePrice: Float!
  currency: String!

  # Calculated pricing (from Bundle interface)
  pricingBreakdown(
    paymentMethod: PaymentMethod
  ): PricingBreakdown
}

type BundlesByCountry {
  country: Country!
  bundles(limit: Int = 3, offset: Int): [Bundle!]!
  pricingRange: PricingRange
  bundleCount: Int!
}

type BundlesByRegion {
  region: String!
  bundles(limit: Int = 3, offset: Int): [Bundle!]!
  bundleCount: Int!
  pricingRange: PricingRange
}

type BundlesByGroup {
  group: String!
  bundles(limit: Int = 3, offset: Int): [Bundle!]!
  bundleCount: Int!
  pricingRange: PricingRange
}

# User Types
type User {
  id: ID!
  email: String!
  firstName: String!
  lastName: String!
  phoneNumber: String
  role: String!
  createdAt: String!
  updatedAt: String!
  orderCount: Int!
}

# Tenant Types
enum TenantType {
  STANDARD
  MASTER
}

type Tenant {
  slug: ID!
  name: String!
  imgUrl: String!
  tenantType: TenantType!
  createdAt: String!
  updatedAt: String!
  # Admin only - users assigned to this tenant
  userCount: Int @auth(role: "ADMIN")
}

type Country {
  iso: ISOCountryCode! # ISO 3166-1 alpha-2 code
  name: String! # English name
  nameHebrew: String
  region: String
  flag: String
  isHighDemand: Boolean @auth(role: "ADMIN")
}

type Trip {
  id: ID!
  name: String!
  description: String!
  region: String!
  countries: [Country!]!
  countryIds: [ISOCountryCode!]!
  createdAt: String!
  updatedAt: String!
  createdBy: String
}

# Authentication Types
input SignInInput {
  email: String!
  password: String!
}

input SignUpInput {
  email: String!
  password: String!
  firstName: String!
  lastName: String!
  phoneNumber: String
}

# Social Authentication
input SocialSignInInput {
  idToken: String! # JWT token from Apple/Google
  firstName: String # For first-time users
  lastName: String # For first-time users
}

# Phone Authentication
input VerifyOTPInput {
  phoneNumber: String!
  otp: String!
  firstName: String # For first-time users
  lastName: String # For first-time users
}

input UpdateProfileInput {
  firstName: String
  lastName: String
  phoneNumber: String
}

type UpdateProfileResponse {
  success: Boolean!
  error: String
  user: User
}

type SendOTPResponse {
  success: Boolean!
  error: String
  messageId: String # For tracking SMS delivery
}

type SignInResponse {
  success: Boolean!
  user: User
  sessionToken: String
  refreshToken: String
  error: String
}

type SignUpResponse {
  success: Boolean!
  user: User
  sessionToken: String
  refreshToken: String
  error: String
}

# Admin Invitation Types
input InviteAdminUserInput {
  email: String!
  role: String!
  redirectUrl: String
}

type InviteAdminUserResponse {
  success: Boolean!
  error: String
  invitedEmail: String
}

type DeleteUserResponse {
  success: Boolean!
  error: String
}

# Trip Management Types
input CreateTripInput {
  name: String!
  description: String!
  regionId: String!
  countryIds: [ISOCountryCode!]!
}

input UpdateTripInput {
  id: ID!
  name: String!
  description: String!
  regionId: String!
  countryIds: [ISOCountryCode!]!
}

type CreateTripResponse {
  success: Boolean!
  error: String
  trip: Trip
}

type UpdateTripResponse {
  success: Boolean!
  error: String
  trip: Trip
}

type DeleteTripResponse {
  success: Boolean!
  error: String
}

# Package Assignment Types
type PackageAssignment {
  id: ID!
  user: User!
  bundleId: String!
  bundleName: String!
  assignedAt: String!
  assignedBy: User!
  status: AssignmentStatus!
  createdAt: String!
  updatedAt: String!
}

enum AssignmentStatus {
  PENDING
  ASSIGNED
  ACTIVATED
  EXPIRED
  CANCELLED
}

type AssignPackageResponse {
  success: Boolean!
  error: String
  assignment: PackageAssignment
}

type PageInfo {
  limit: Int!
  offset: Int!
  total: Int!
  pages: Int!
  currentPage: Int!
}

# Order Types
type Order {
  id: ID!
  reference: String! # eSIM Go order reference
  status: OrderStatus!
  bundleId: String
  bundleName: String
  quantity: Int!
  totalPrice: Float!
  currency: String! # Currency code (USD, ILS, EUR, etc.)
  esims: [ESIM!]!
  user: User # User who placed the order
  createdAt: String!
  updatedAt: String!
}

enum OrderStatus {
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

input OrderFilter {
  status: OrderStatus
  fromDate: String
  toDate: String
}

# eSIM Types (updated)
type ESIM {
  id: ID!
  order: Order!
  bundleId: String!
  bundleName: String!
  iccid: String! # eSIM identifier
  customerRef: String
  qrCode: String # QR code for eSIM installation
  status: ESIMStatus!
  assignedDate: String
  lastAction: String
  actionDate: String
  bundles: [ESIMBundle!]!
  usage: ESIMUsage!
  createdAt: String!
  updatedAt: String!
  smdpAddress: String # SMDP+ address for eSIM activation
  matchingId: String # Matching ID for eSIM activation
  installationLinks: InstallationLinks # All activation link formats
}

# Installation links for direct eSIM activation
type InstallationLinks {
  """
  iOS 17.4+ direct activation link (no QR scanning needed)
  """
  universalLink: String!
  
  """
  LPA scheme for Android/Windows direct activation
  """
  lpaScheme: String!
  
  """
  Manual entry components for all devices
  """
  manual: ManualInstallation!
  
  """
  QR code data string (LPA format) for fallback
  """
  qrCodeData: String!
}

type ManualInstallation {
  """
  SM-DP+ server address
  """
  smDpAddress: String!
  
  """
  Activation code
  """
  activationCode: String!
  
  """
  Optional confirmation code
  """
  confirmationCode: String
}

type ESIMBundle {
  id: ID!
  name: String!
  state: BundleState!
  dataUsed: Float! # MB used
  dataRemaining: Float # MB remaining (null for unlimited)
  startDate: String
  endDate: String
}

enum BundleState {
  PROCESSING
  ACTIVE
  INACTIVE
  SUSPENDED
  EXPIRED
  CANCELLED
}

type ESIMUsage {
  totalUsed: Float! # Total MB used
  totalRemaining: Float # Total MB remaining (null for unlimited)
  activeBundles: [ESIMBundle!]!
}

enum ESIMStatus {
  PROCESSING
  ASSIGNED
  ACTIVE
  SUSPENDED
  EXPIRED
  CANCELLED
}

# Admin eSIM types
type AdminESIM {
  id: ID!
  iccid: String!
  userId: String!
  orderId: String!
  status: String!
  apiStatus: String
  customerRef: String
  assignedDate: String
  activationCode: String
  qrCodeUrl: String
  smdpAddress: String
  matchingId: String
  lastAction: String
  actionDate: String
  createdAt: String!
  updatedAt: String
  usage: ESIMUsage
  esim_bundles: [JSON]
  user: AdminESIMUser
  order: AdminESIMOrder
}

type AdminESIMUser {
  id: ID!
  email: String
  firstName: String
  lastName: String
}

type AdminESIMOrder {
  id: ID!
  reference: String!
  bundleName: String
}

type AdminESIMDetails {
  id: ID!
  iccid: String!
  userId: String!
  orderId: String!
  status: String!
  customerRef: String
  assignedDate: String
  activationCode: String
  qrCodeUrl: String
  smdpAddress: String
  matchingId: String
  lastAction: String
  actionDate: String
  createdAt: String!
  updatedAt: String
  apiDetails: JSON
  usage: ESIMUsage
  order: Order
}

# eSIM Operations
input PurchaseESIMInput {
  quantity: Int!
  customerReference: String
  autoActivate: Boolean
}

type PurchaseESIMResponse {
  success: Boolean!
  order: Order
  error: String
}

type ActivateESIMResponse {
  success: Boolean!
  esim: ESIM
  error: String
}

type ESIMActionResponse {
  success: Boolean!
  esim: ESIM
  error: String
}

type ESIMStatusUpdate {
  esimId: ID!
  status: ESIMStatus!
  dataUsed: Float
  dataRemaining: Float
  updatedAt: String!
}

type CatalogSyncProgressUpdate {
  jobId: ID!
  jobType: SyncJobType!
  status: SyncJobStatus!
  bundleGroup: String
  countryId: String
  bundlesProcessed: Int!
  bundlesAdded: Int!
  bundlesUpdated: Int!
  totalBundles: Int
  progress: Float! # Progress percentage (0-100)
  message: String
  errorMessage: String
  startedAt: String!
  updatedAt: String!
}

type PricingPipelineStepUpdate {
  correlationId: String!
  name: String!
  timestamp: String!
  state: JSON
  appliedRules: [String!]
  debug: JSON
}

# Basic checkout session type (enhanced)
type CheckoutSession {
  id: ID!
  token: String! # JWT token for secure navigation
  expiresAt: DateTime!
  isComplete: Boolean!
  timeRemaining: Int # seconds until expiration
  createdAt: DateTime!
  # Additional fields for frontend
  planSnapshot: JSON
  pricing: JSON
  steps: JSON
  paymentStatus: String
  metadata: JSON
  orderId: ID # Order ID after completion
}

# Input for creating a checkout session
input CreateCheckoutSessionInput {
  numOfDays: Int!
  regionId: String
  countryId: String
  group: String
}

# Response types
type CreateCheckoutSessionResponse {
  success: Boolean!
  session: CheckoutSession
  error: String
}

type GetCheckoutSessionResponse {
  success: Boolean!
  session: CheckoutSession
  error: String
}

# Input for updating checkout steps
input UpdateCheckoutStepInput {
  token: String!
  stepType: CheckoutStepType!
  data: JSON! # Flexible data based on step type
}

# Response for step updates
type UpdateCheckoutStepResponse {
  success: Boolean!
  session: CheckoutSession
  nextStep: CheckoutStepType
  error: String
}

# Enum for step types
enum CheckoutStepType {
  AUTHENTICATION
  DELIVERY
  PAYMENT
}

# Input for processing final payment
input ProcessCheckoutPaymentInput {
  token: String!
  paymentMethodId: String! # From Stripe/payment provider
  savePaymentMethod: Boolean = false
}

# Response for payment processing
type ProcessCheckoutPaymentResponse {
  success: Boolean!
  orderId: ID
  session: CheckoutSession
  paymentIntentId: String
  webhookProcessing: Boolean # Indicates webhook is handling completion
  error: String
}

extend type Query {
  getCheckoutSession(token: String!): GetCheckoutSessionResponse!
}

extend type Mutation {
  createCheckoutSession(
    input: CreateCheckoutSessionInput!
  ): CreateCheckoutSessionResponse!
  updateCheckoutStep(
    input: UpdateCheckoutStepInput!
  ): UpdateCheckoutStepResponse!
  processCheckoutPayment(
    input: ProcessCheckoutPaymentInput!
  ): ProcessCheckoutPaymentResponse!
  validateOrder(input: ValidateOrderInput!): ValidateOrderResponse!
  
  # Pricing Rules Engine
  createPricingRule(input: CreatePricingRuleInput!): PricingRule!
  updatePricingRule(id: ID!, input: UpdatePricingRuleInput!): PricingRule!
  deletePricingRule(id: ID!): Boolean!
  togglePricingRule(id: ID!): PricingRule!
  updatePricingRulePriorities(updates: [PricingRulePriorityUpdate!]!): [PricingRule!]!
  clonePricingRule(id: ID!, newName: String!): PricingRule!
  
  # Tenant Management (Master tenant only)
  createTenant(input: CreateTenantInput!): Tenant! @auth
  updateTenant(slug: ID!, input: UpdateTenantInput!): Tenant! @auth
  deleteTenant(slug: ID!): TenantOperationResponse! @auth
  assignUserToTenant(userId: ID!, tenantSlug: ID!, role: String): TenantOperationResponse! @auth
  removeUserFromTenant(userId: ID!, tenantSlug: ID!): TenantOperationResponse! @auth
}

# Tenant Management Inputs
input CreateTenantInput {
  slug: ID!
  name: String!
  imgUrl: String!
  tenantType: TenantType = STANDARD
}

input UpdateTenantInput {
  name: String
  imgUrl: String
  tenantType: TenantType
}

input TenantFilter {
  tenantType: TenantType
  search: String
}

type TenantConnection {
  nodes: [Tenant!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

type TenantOperationResponse {
  success: Boolean!
  message: String
}

# Pricing Types
type PricingBreakdown {
  # Bundle Information - Public
  bundle: CountryBundle!
  country: Country!
  duration: Int!
  currency: String!

  # Public pricing fields (what users pay)
  totalCost: Float! # Total cost (cost + markup) before discounts
  discountValue: Float! # Total discount amount
  priceAfterDiscount: Float! # Final price users pay
  finalPrice: Float! # Final price users pay
  # Admin-only business sensitive fields
  cost: Float! @auth(role: "ADMIN") # Base cost from supplier
  markup: Float! @auth(role: "ADMIN") # Markup amount added to cost
  discountRate: Float! @auth(role: "ADMIN") # Discount percentage
  processingRate: Float! @auth(role: "ADMIN") # Processing fee percentage
  processingCost: Float! @auth(role: "ADMIN") # Processing fee amount
  finalRevenue: Float! @auth(role: "ADMIN") # What customer pays (same as priceAfterDiscount)
  revenueAfterProcessing: Float! @auth(role: "ADMIN") # What we receive after processing fees
  netProfit: Float! @auth(role: "ADMIN") # Final profit
  discountPerDay: Float! @auth(role: "ADMIN") # Per-day discount rate
  # Rule-based pricing breakdown - Admin only
  appliedRules: [AppliedRule!] @auth(role: "ADMIN") # Rules that affected the pricing (nullable)
  discounts: [DiscountApplication!] @auth(role: "ADMIN") # Detailed discount breakdown (nullable)
  
  # Pipeline metadata - Admin only
  unusedDays: Int @auth(role: "ADMIN") # Days not used from selected bundle
  selectedReason: String @auth(role: "ADMIN") # Bundle selection reason (exact_match, next_available, etc.)
  
  # Additional pricing engine fields - Admin only
  totalCostBeforeProcessing: Float @auth(role: "ADMIN") # Price before processing fees
}

type PricingRange {
  min: Float!
  max: Float!
}

# Individual bundles for a specific country
type CountryBundle {
  id: ID!
  name: String!
  country: Country!
  duration: Int!
  price: Float
  currency: String!
  pricingBreakdown: PricingBreakdown
  isUnlimited: Boolean!
  data: Float
  group: String

  # Rule-based pricing breakdown - Admin only
  appliedRules: [AppliedRule!] @auth(role: "ADMIN") # Rules that affected the pricing (nullable)
}

# Pricing Rules Engine Types
enum RuleCategory {
  DISCOUNT
  CONSTRAINT
  FEE
  BUNDLE_ADJUSTMENT
}

enum ConditionOperator {
  EQUALS
  NOT_EQUALS
  GREATER_THAN
  LESS_THAN
  BETWEEN
  IN
  NOT_IN
  EXISTS
  NOT_EXISTS
}

enum ActionType {
  APPLY_DISCOUNT_PERCENTAGE
  APPLY_FIXED_DISCOUNT
  SET_MINIMUM_PRICE
  SET_MINIMUM_PROFIT
  ADD_MARKUP
  SET_PROCESSING_RATE
  SET_DISCOUNT_PER_UNUSED_DAY
}

type RuleCondition {
  field: String!
  operator: ConditionOperator!
  value: JSON!
  type: String
}

type RuleAction {
  type: ActionType!
  value: Float!
  metadata: JSON
}

input RuleConditionInput {
  field: String!
  operator: ConditionOperator!
  value: JSON!
  type: String
}

input RuleActionInput {
  type: ActionType!
  value: Float!
  metadata: JSON
}

input PricingRuleFilter {
  category: RuleCategory
  isActive: Boolean
  isEditable: Boolean
  validFrom: String
  validUntil: String
}

type PricingRule {
  id: ID!
  category: RuleCategory!
  name: String!
  description: String

  # Rule definition
  conditions: [RuleCondition!]!
  actions: [RuleAction!]!

  # Metadata
  priority: Int!
  isActive: Boolean!
  isEditable: Boolean!
  validFrom: String
  validUntil: String

  # Audit
  createdBy: String!
  createdAt: String!
  updatedAt: String!
}

input CreatePricingRuleInput {
  category: RuleCategory!
  name: String!
  description: String
  conditions: [RuleConditionInput!]!
  actions: [RuleActionInput!]!
  priority: Int!
  isActive: Boolean
  validFrom: String
  validUntil: String
}

input UpdatePricingRuleInput {
  category: RuleCategory
  name: String
  description: String
  conditions: [RuleConditionInput!]
  actions: [RuleActionInput!]
  priority: Int
  isActive: Boolean
  validFrom: String
  validUntil: String
}

input PricingRulePriorityUpdate {
  id: ID!
  priority: Int!
}

type AppliedRule {
  id: ID!
  name: String!
  category: RuleCategory!
  impact: Float!
}

# Represents a discount that was applied during pricing calculation
type DiscountApplication {
  type: String!          # The type of discount (e.g., "unused-days", "coupon", "corporate")
  amount: Float!         # The discount amount in currency
  percentage: Float      # The discount percentage (if applicable)
  description: String    # Human-readable description of the discount
}

# Batch pricing input
input CalculatePriceInput {
  numOfDays: Int!
  countryId: String
  regionId: String
  paymentMethod: PaymentMethod
  promo: String
  groups: [String!]
}

# Pricing Configuration Types (Legacy - to be migrated to rules)
type PricingConfiguration {
  id: ID!
  name: String!
  description: String!

  # Bundle filters (null = applies to all)
  countryId: String
  regionId: String
  duration: Int
  bundleGroup: String

  # Configuration values
  discountRate: Float! # Discount percentage (default: 0%)
  markupAmount: Float # Fixed markup amount in USD (null = use global markup)
  discountPerDay: Float # Discount rate per unused day (0.10 = 10% per day)
  # Metadata
  isActive: Boolean!
  createdBy: String!
  createdAt: String!
  updatedAt: String!
}

input UpdatePricingConfigurationInput {
  id: ID # If provided, update existing; if null, create new
  name: String!
  description: String!

  # Bundle filters
  countryId: String
  regionId: String
  duration: Int
  bundleGroup: String

  # Configuration values
  discountRate: Float!
  markupAmount: Float # Fixed markup amount in USD (null = use global markup)
  discountPerDay: Float # Discount rate per unused day (0.10 = 10% per day)
  isActive: Boolean!
}

type UpdatePricingConfigurationResponse {
  success: Boolean!
  configuration: PricingConfiguration
  error: String
}

scalar ISOCountryCode
scalar DateTime
scalar JSON

# Payment method enum for processing fee calculation
enum PaymentMethod {
  ISRAELI_CARD
  FOREIGN_CARD
  BIT
  AMEX
  DINERS
}

# Payment method information with processing rates
type PaymentMethodInfo {
  value: PaymentMethod!
  label: String!
  description: String!
  processingRate: Float!
  icon: String # Icon identifier for UI
  isActive: Boolean!
}

# Processing Fee Configuration Types
type ProcessingFeeConfiguration {
  id: ID!
  # Main processing fees (percentages)
  israeliCardsRate: Float! # עמלות סליקה עסקאות ש"ח בכרטיסים שהונפקו בישראל
  foreignCardsRate: Float! # עמלות סליקה כרטיסים שהונפקו בחו"ל
  premiumDinersRate: Float! # תוספת דיינרס
  premiumAmexRate: Float! # תוספת אמקס
  bitPaymentRate: Float! # תוספת ביט
  # Fixed fees (amounts in ILS)
  fixedFeeNIS: Float! # עמלה קבועה לעסקה בש"ח
  fixedFeeForeign: Float! # עמלה קבועה לעסקה במט"ח
  monthlyFixedCost: Float! # עלות חודשית קבועה
  bankWithdrawalFee: Float! # עלות משיכה לחשבון הבנק
  monthlyMinimumFee: Float! # עמלת מינימום חודשית
  setupCost: Float! # עלות הקמה
  # Additional services (amounts in ILS)
  threeDSecureFee: Float! # 3DSecure
  chargebackFee: Float! # עמלת הכחשות עסקה
  cancellationFee: Float! # עמלת ביטול עסקה
  invoiceServiceFee: Float! # שירותי חשבוניות
  appleGooglePayFee: Float! # Apple/Google Pay
  # Metadata
  isActive: Boolean! # Whether this configuration is currently active
  effectiveFrom: DateTime! # When this configuration becomes effective
  effectiveTo: DateTime # When this configuration expires (null for current)
  createdAt: DateTime!
  updatedAt: DateTime!
  createdBy: String! # User who created this configuration
  notes: String # Optional notes about this configuration
}

# Input for creating/updating processing fee configuration
input ProcessingFeeConfigurationInput {
  israeliCardsRate: Float!
  foreignCardsRate: Float!
  premiumDinersRate: Float!
  premiumAmexRate: Float!
  bitPaymentRate: Float!
  fixedFeeNIS: Float!
  fixedFeeForeign: Float!
  monthlyFixedCost: Float!
  bankWithdrawalFee: Float!
  monthlyMinimumFee: Float!
  setupCost: Float!
  threeDSecureFee: Float!
  chargebackFee: Float!
  cancellationFee: Float!
  invoiceServiceFee: Float!
  appleGooglePayFee: Float!
  effectiveFrom: DateTime!
  effectiveTo: DateTime
  notes: String
}

# Order Validation Types
input ValidateOrderInput {
  bundleName: String!
  quantity: Int!
  customerReference: String
}

type ValidateOrderResponse {
  success: Boolean!
  isValid: Boolean!
  bundleDetails: JSON
  totalPrice: Float
  currency: String
  error: String
  errorCode: String
}

# High Demand Countries Types
type ToggleHighDemandResponse {
  success: Boolean!
  countryId: String!
  isHighDemand: Boolean!
  error: String
}

# Pricing Filters Types
type PricingFilters {
  groups: [String!]!
  durations: [DurationRange!]!
  dataTypes: [DataType!]!
}

type DurationRange {
  label: String!
  value: String!
  minDays: Int!
  maxDays: Int!
}

type DataType {
  label: String!
  value: String!
  isUnlimited: Boolean!
  minDataMB: Int
  maxDataMB: Int
}

input TestPricingContext {
  bundleId: String!
  bundleName: String!
  bundleGroup: String!
  duration: Int!
  cost: Float!
  countryId: String!
  regionId: String!
  userId: String
  isNewUser: Boolean
  paymentMethod: PaymentMethod!
  requestedDuration: Int
}

# Bundle Data Amount Aggregation Types
type BundleDataAggregation {
  total: Int!
  unlimited: Int!
  byDataAmount: [DataAmountGroup!]!
  byDuration: [DurationGroup!]!
  byGroup: [GroupDataStats!]!
  lastUpdated: String!
}

type DataAmountGroup {
  dataAmount: Int!
  count: Int!
  percentage: Float!
}

type DurationGroup {
  duration: Int!
  count: Int!
  percentage: Float!
  category: String!
}

type GroupDataStats {
  group: String!
  total: Int!
  unlimited: Int!
  limited: Int!
  averageDataAmount: Float!
}

# Catalog Sync History Types
input SyncHistoryParams {
  limit: Int = 50
  offset: Int = 0
  status: SyncJobStatus
  type: SyncJobType
  fromDate: String
  toDate: String
}

type CatalogSyncJob {
  id: ID!
  jobType: String! # For compatibility with frontend
  type: SyncJobType!
  status: String! # For compatibility with frontend
  priority: String! # For compatibility with frontend
  group: String
  countryId: String
  bundlesProcessed: Int
  bundlesAdded: Int
  bundlesUpdated: Int
  startedAt: String!
  completedAt: String
  duration: Int # Duration in milliseconds
  errorMessage: String
  metadata: JSON
  createdAt: String!
  updatedAt: String!
}

type CatalogSyncHistoryConnection {
  jobs: [CatalogSyncJob!]!
  totalCount: Int!
}

enum SyncJobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum SyncJobType {
  FULL_SYNC
  GROUP_SYNC
  COUNTRY_SYNC
  METADATA_SYNC
}

# Catalog Bundle System Types (for new catalog system)
input SearchCatalogCriteria {
  bundleGroups: [String!]
  countries: [String!]
  regions: [String!]
  minDuration: Int
  maxDuration: Int
  unlimited: Boolean
  search: String
  limit: Int = 50
  offset: Int = 0
}

type CatalogBundleConnection {
  bundles: [CatalogBundle!]!
  totalCount: Int!
}

type CatalogCountryBundles {
  country: String!
  bundleCount: Int!
  bundles: [CatalogBundle!]!
}

# Trigger Sync Types
input TriggerSyncParams {
  type: SyncJobType!
  bundleGroup: String
  countryId: String
  priority: String = "normal"
  force: Boolean = false
}

type TriggerSyncResponse {
  success: Boolean!
  jobId: String
  message: String
  error: String
  conflictingJob: ConflictingJobInfo
}

type ConflictingJobInfo {
  id: String!
  jobType: String!
  status: String!
  createdAt: String!
  startedAt: String
}
