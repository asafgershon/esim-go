# eSIM Go GraphQL Schema
# Main schema file for the eSIM Go platform

type Query {
  # Basic hello query for testing
  hello: String!

  # User authentication and profile
  me: User @auth
  users: [User!]! @auth(role: "ADMIN")
  orders: [Order!]! @auth(role: "ADMIN")

  # eSIM queries
  myESIMs: [ESIM!]! @auth
  esimDetails(id: ID!): ESIM @auth

  dataPlans(filter: DataPlanFilter): DataPlanConnection!
  dataPlan(id: ID!): DataPlan

  # Order queries
  myOrders(filter: OrderFilter): [Order!]! @auth
  orderDetails(id: ID!): Order @auth

  countries: [Country!]!
  trips: [Trip!]!

  # Calculate price
  calculatePrice(numOfDays: Int!, regionId: String!, countryId: String!): PricingBreakdown!
  
  # Batch calculate prices for multiple bundles
  calculatePrices(inputs: [CalculatePriceInput!]!): [PricingBreakdown!]!
  
  # Pricing configurations
  pricingConfigurations: [PricingConfiguration!]!
}

type Mutation {
  # Authentication
  signIn(input: SignInInput!): SignInResponse
  signUp(input: SignUpInput!): SignUpResponse

  # Social Authentication
  signInWithApple(input: SocialSignInInput!): SignInResponse
  signInWithGoogle(input: SocialSignInInput!): SignInResponse

  # Phone Authentication
  sendPhoneOTP(phoneNumber: String!): SendOTPResponse
  verifyPhoneOTP(input: VerifyOTPInput!): SignInResponse

  # User Management
  updateUserRole(userId: ID!, role: String!): User @auth(role: "ADMIN")
  inviteAdminUser(input: InviteAdminUserInput!): InviteAdminUserResponse @auth(role: "ADMIN")
  deleteUser(userId: ID!): DeleteUserResponse @auth(role: "ADMIN")
  
  # Pricing configuration management
  updatePricingConfiguration(input: UpdatePricingConfigurationInput!): UpdatePricingConfigurationResponse @auth(role: "ADMIN")
  
  # Package Assignment
  assignPackageToUser(userId: ID!, planId: ID!): AssignPackageResponse @auth(role: "ADMIN")

  # eSIM operations
  purchaseESIM(planId: ID!, input: PurchaseESIMInput!): PurchaseESIMResponse
    @auth
  activateESIM(esimId: ID!): ActivateESIMResponse @auth
  suspendESIM(esimId: ID!): ESIMActionResponse @auth
  restoreESIM(esimId: ID!): ESIMActionResponse @auth
  cancelESIM(esimId: ID!): ESIMActionResponse @auth
  updateESIMReference(esimId: ID!, reference: String!): ESIMActionResponse @auth
}

type Subscription {
  # Real-time eSIM status updates
  esimStatusUpdated(esimId: ID!): ESIMStatusUpdate! @auth
}

# User Types
type User {
  id: ID!
  email: String!
  firstName: String!
  lastName: String!
  phoneNumber: String
  role: String!
  createdAt: String!
  updatedAt: String!
}

type Country {
  iso: ISOCountryCode! # ISO 3166-1 alpha-2 code
  name: String! # English name
  nameHebrew: String
  region: String!
  flag: String
}

type Trip {
  name: String!
  description: String!
  regionId: String!
  countries: [Country!]!
  countryIds: [ISOCountryCode!]!
}

# Authentication Types
input SignInInput {
  email: String!
  password: String!
}

input SignUpInput {
  email: String!
  password: String!
  firstName: String!
  lastName: String!
  phoneNumber: String
}

# Social Authentication
input SocialSignInInput {
  idToken: String! # JWT token from Apple/Google
  firstName: String # For first-time users
  lastName: String # For first-time users
}

# Phone Authentication
input VerifyOTPInput {
  phoneNumber: String!
  otp: String!
  firstName: String # For first-time users
  lastName: String # For first-time users
}

type SendOTPResponse {
  success: Boolean!
  error: String
  messageId: String # For tracking SMS delivery
}

type SignInResponse {
  success: Boolean!
  user: User
  sessionToken: String
  refreshToken: String
  error: String
}

type SignUpResponse {
  success: Boolean!
  user: User
  sessionToken: String
  refreshToken: String
  error: String
}

# Admin Invitation Types
input InviteAdminUserInput {
  email: String!
  role: String!
  redirectUrl: String
}

type InviteAdminUserResponse {
  success: Boolean!
  error: String
  invitedEmail: String
}

type DeleteUserResponse {
  success: Boolean!
  error: String
}

# Package Assignment Types
type PackageAssignment {
  id: ID!
  user: User!
  dataPlan: DataPlan!
  assignedAt: String!
  assignedBy: User!
  status: AssignmentStatus!
  createdAt: String!
  updatedAt: String!
}

enum AssignmentStatus {
  PENDING
  ASSIGNED
  ACTIVATED
  EXPIRED
  CANCELLED
}

type AssignPackageResponse {
  success: Boolean!
  error: String
  assignment: PackageAssignment
}

# Data Plan Types (from eSIM Go catalogue)
type DataPlan {
  id: ID!
  name: String! # eSIM Go bundle name
  description: String!
  region: String!
  countries: [Country!]!
  duration: Int! # Duration in days
  price: Float! # Price in USD
  currency: String!
  isUnlimited: Boolean!
  bundleGroup: String
  features: [String!]!
  availableQuantity: Int
}

# Data plan filtering
input DataPlanFilter {
  region: String
  country: String # ISO code
  duration: Int # Days
  maxPrice: Float
  bundleGroup: String
  search: String # Search term for name/description
  limit: Int # Number of items per page (default: 50, max: 200)
  offset: Int # Starting position for pagination (default: 0)
}

# Pagination types for data plans
type DataPlanConnection {
  items: [DataPlan!]!
  totalCount: Int!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  pageInfo: PageInfo!
}

type PageInfo {
  limit: Int!
  offset: Int!
  total: Int!
  pages: Int!
  currentPage: Int!
}

# Order Types
type Order {
  id: ID!
  reference: String! # eSIM Go order reference
  status: OrderStatus!
  dataPlan: DataPlan
  quantity: Int!
  totalPrice: Float!
  esims: [ESIM!]!
  createdAt: String!
  updatedAt: String!
}

enum OrderStatus {
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

input OrderFilter {
  status: OrderStatus
  fromDate: String
  toDate: String
}

# eSIM Types (updated)
type ESIM {
  id: ID!
  order: Order!
  plan: DataPlan!
  iccid: String! # eSIM identifier
  customerRef: String
  qrCode: String # QR code for eSIM installation
  status: ESIMStatus!
  assignedDate: String
  lastAction: String
  actionDate: String
  bundles: [ESIMBundle!]!
  usage: ESIMUsage!
  createdAt: String!
  updatedAt: String!
}

type ESIMBundle {
  id: ID!
  name: String!
  state: BundleState!
  dataUsed: Float! # MB used
  dataRemaining: Float # MB remaining (null for unlimited)
  startDate: String
  endDate: String
}

enum BundleState {
  PROCESSING
  ACTIVE
  INACTIVE
  SUSPENDED
  EXPIRED
  CANCELLED
}

type ESIMUsage {
  totalUsed: Float! # Total MB used
  totalRemaining: Float # Total MB remaining (null for unlimited)
  activeBundles: [ESIMBundle!]!
}

enum ESIMStatus {
  PROCESSING
  ASSIGNED
  ACTIVE
  SUSPENDED
  EXPIRED
  CANCELLED
}

# eSIM Operations
input PurchaseESIMInput {
  quantity: Int!
  customerReference: String
  autoActivate: Boolean
}

type PurchaseESIMResponse {
  success: Boolean!
  order: Order
  error: String
}

type ActivateESIMResponse {
  success: Boolean!
  esim: ESIM
  error: String
}

type ESIMActionResponse {
  success: Boolean!
  esim: ESIM
  error: String
}

type ESIMStatusUpdate {
  esimId: ID!
  status: ESIMStatus!
  dataUsed: Float
  dataRemaining: Float
  updatedAt: String!
}

# Basic checkout session type (enhanced)
type CheckoutSession {
  id: ID!
  token: String! # JWT token for secure navigation
  expiresAt: DateTime!
  isComplete: Boolean!
  timeRemaining: Int # seconds until expiration
  createdAt: DateTime!
  # Additional fields for frontend
  planSnapshot: JSON
  pricing: JSON
  steps: JSON
  paymentStatus: String
  metadata: JSON
  orderId: ID # Order ID after completion
}

# Input for creating a checkout session
input CreateCheckoutSessionInput {
  numOfDays: Int!
  regionId: String!
  countryId: String!
}

# Response types
type CreateCheckoutSessionResponse {
  success: Boolean!
  session: CheckoutSession
  error: String
}

type GetCheckoutSessionResponse {
  success: Boolean!
  session: CheckoutSession
  error: String
}

# Input for updating checkout steps
input UpdateCheckoutStepInput {
  token: String!
  stepType: CheckoutStepType!
  data: JSON! # Flexible data based on step type
}

# Response for step updates
type UpdateCheckoutStepResponse {
  success: Boolean!
  session: CheckoutSession
  nextStep: CheckoutStepType
  error: String
}

# Enum for step types
enum CheckoutStepType {
  AUTHENTICATION
  DELIVERY
  PAYMENT
}

# Input for processing final payment
input ProcessCheckoutPaymentInput {
  token: String!
  paymentMethodId: String! # From Stripe/payment provider
  savePaymentMethod: Boolean = false
}

# Response for payment processing
type ProcessCheckoutPaymentResponse {
  success: Boolean!
  orderId: ID
  session: CheckoutSession
  paymentIntentId: String
  webhookProcessing: Boolean # Indicates webhook is handling completion
  error: String
}

extend type Query {
  getCheckoutSession(token: String!): GetCheckoutSessionResponse!
}

extend type Mutation {
  createCheckoutSession(
    input: CreateCheckoutSessionInput!
  ): CreateCheckoutSessionResponse!
  updateCheckoutStep(
    input: UpdateCheckoutStepInput!
  ): UpdateCheckoutStepResponse!
  processCheckoutPayment(
    input: ProcessCheckoutPaymentInput!
  ): ProcessCheckoutPaymentResponse!
  validateOrder(
    input: ValidateOrderInput!
  ): ValidateOrderResponse!
}

# Pricing Types
type PricingBreakdown {
  # Bundle Information
  bundleName: String!
  countryName: String!
  duration: Int!
  
  # Base Costs (configured values)
  cost: Float!
  costPlus: Float!
  totalCost: Float!
  
  # Discount Configuration
  discountRate: Float! # percentage (e.g., 0.30 for 30%)
  discountValue: Float! # computed: totalCost * discountRate
  priceAfterDiscount: Float! # computed: totalCost - discountValue
  
  # Processing Fees
  processingRate: Float! # percentage (e.g., 0.045 for 4.5%)
  processingCost: Float! # computed: priceAfterDiscount * processingRate
  revenueAfterProcessing: Float! # computed: priceAfterDiscount - processingCost
  
  # Final Revenue
  finalRevenue: Float! # computed: revenueAfterProcessing - cost - costPlus
  
  # Currency
  currency: String!
}


# Batch pricing input
input CalculatePriceInput {
  numOfDays: Int!
  regionId: String!
  countryId: String!
}

# Pricing Configuration Types
type PricingConfiguration {
  id: ID!
  name: String!
  description: String!
  
  # Bundle filters (null = applies to all)
  countryId: String
  regionId: String
  duration: Int
  bundleGroup: String
  
  # Configuration values
  costSplitPercent: Float! # What % of bundle price is base cost (default: 60%)
  discountRate: Float! # Discount percentage (default: 30%)
  processingRate: Float! # Processing fee percentage (default: 4.5%)
  
  # Metadata
  isActive: Boolean!
  priority: Int! # Higher priority overrides lower priority
  createdBy: String!
  createdAt: String!
  updatedAt: String!
}

input UpdatePricingConfigurationInput {
  id: ID # If provided, update existing; if null, create new
  name: String!
  description: String!
  
  # Bundle filters
  countryId: String
  regionId: String
  duration: Int
  bundleGroup: String
  
  # Configuration values
  costSplitPercent: Float!
  discountRate: Float!
  processingRate: Float!
  
  isActive: Boolean!
  priority: Int!
}

type UpdatePricingConfigurationResponse {
  success: Boolean!
  configuration: PricingConfiguration
  error: String
}

scalar ISOCountryCode
scalar DateTime
scalar JSON

# Order Validation Types
input ValidateOrderInput {
  bundleName: String!
  quantity: Int!
  customerReference: String
}

type ValidateOrderResponse {
  success: Boolean!
  isValid: Boolean!
  bundleDetails: JSON
  totalPrice: Float
  currency: String
  error: String
  errorCode: String
}
